/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};

// node_modules/.pnpm/obsidian-daily-notes-interface@0.9.4_@codemirror+state@6.4.1_@codemirror+view@6.25.1/node_modules/obsidian-daily-notes-interface/dist/main.js
var require_main = __commonJS({
  "node_modules/.pnpm/obsidian-daily-notes-interface@0.9.4_@codemirror+state@6.4.1_@codemirror+view@6.25.1/node_modules/obsidian-daily-notes-interface/dist/main.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var obsidian = require("obsidian");
    var DEFAULT_DAILY_NOTE_FORMAT = "YYYY-MM-DD";
    var DEFAULT_WEEKLY_NOTE_FORMAT = "gggg-[W]ww";
    var DEFAULT_MONTHLY_NOTE_FORMAT = "YYYY-MM";
    var DEFAULT_QUARTERLY_NOTE_FORMAT = "YYYY-[Q]Q";
    var DEFAULT_YEARLY_NOTE_FORMAT = "YYYY";
    function shouldUsePeriodicNotesSettings(periodicity) {
      var _a, _b;
      const periodicNotes = window.app.plugins.getPlugin("periodic-notes");
      return periodicNotes && ((_b = (_a = periodicNotes.settings) == null ? void 0 : _a[periodicity]) == null ? void 0 : _b.enabled);
    }
    function getDailyNoteSettings() {
      var _a, _b, _c, _d;
      try {
        const { internalPlugins, plugins } = window.app;
        if (shouldUsePeriodicNotesSettings("daily")) {
          const { format: format2, folder: folder2, template: template2 } = ((_b = (_a = plugins.getPlugin("periodic-notes")) == null ? void 0 : _a.settings) == null ? void 0 : _b.daily) || {};
          return {
            format: format2 || DEFAULT_DAILY_NOTE_FORMAT,
            folder: (folder2 == null ? void 0 : folder2.trim()) || "",
            template: (template2 == null ? void 0 : template2.trim()) || ""
          };
        }
        const { folder, format, template } = ((_d = (_c = internalPlugins.getPluginById("daily-notes")) == null ? void 0 : _c.instance) == null ? void 0 : _d.options) || {};
        return {
          format: format || DEFAULT_DAILY_NOTE_FORMAT,
          folder: (folder == null ? void 0 : folder.trim()) || "",
          template: (template == null ? void 0 : template.trim()) || ""
        };
      } catch (err) {
        console.info("No custom daily note settings found!", err);
      }
    }
    function getWeeklyNoteSettings() {
      var _a, _b, _c, _d, _e, _f, _g;
      try {
        const pluginManager = window.app.plugins;
        const calendarSettings = (_a = pluginManager.getPlugin("calendar")) == null ? void 0 : _a.options;
        const periodicNotesSettings = (_c = (_b = pluginManager.getPlugin("periodic-notes")) == null ? void 0 : _b.settings) == null ? void 0 : _c.weekly;
        if (shouldUsePeriodicNotesSettings("weekly")) {
          return {
            format: periodicNotesSettings.format || DEFAULT_WEEKLY_NOTE_FORMAT,
            folder: ((_d = periodicNotesSettings.folder) == null ? void 0 : _d.trim()) || "",
            template: ((_e = periodicNotesSettings.template) == null ? void 0 : _e.trim()) || ""
          };
        }
        const settings = calendarSettings || {};
        return {
          format: settings.weeklyNoteFormat || DEFAULT_WEEKLY_NOTE_FORMAT,
          folder: ((_f = settings.weeklyNoteFolder) == null ? void 0 : _f.trim()) || "",
          template: ((_g = settings.weeklyNoteTemplate) == null ? void 0 : _g.trim()) || ""
        };
      } catch (err) {
        console.info("No custom weekly note settings found!", err);
      }
    }
    function getMonthlyNoteSettings() {
      var _a, _b, _c, _d;
      const pluginManager = window.app.plugins;
      try {
        const settings = shouldUsePeriodicNotesSettings("monthly") && ((_b = (_a = pluginManager.getPlugin("periodic-notes")) == null ? void 0 : _a.settings) == null ? void 0 : _b.monthly) || {};
        return {
          format: settings.format || DEFAULT_MONTHLY_NOTE_FORMAT,
          folder: ((_c = settings.folder) == null ? void 0 : _c.trim()) || "",
          template: ((_d = settings.template) == null ? void 0 : _d.trim()) || ""
        };
      } catch (err) {
        console.info("No custom monthly note settings found!", err);
      }
    }
    function getQuarterlyNoteSettings() {
      var _a, _b, _c, _d;
      const pluginManager = window.app.plugins;
      try {
        const settings = shouldUsePeriodicNotesSettings("quarterly") && ((_b = (_a = pluginManager.getPlugin("periodic-notes")) == null ? void 0 : _a.settings) == null ? void 0 : _b.quarterly) || {};
        return {
          format: settings.format || DEFAULT_QUARTERLY_NOTE_FORMAT,
          folder: ((_c = settings.folder) == null ? void 0 : _c.trim()) || "",
          template: ((_d = settings.template) == null ? void 0 : _d.trim()) || ""
        };
      } catch (err) {
        console.info("No custom quarterly note settings found!", err);
      }
    }
    function getYearlyNoteSettings() {
      var _a, _b, _c, _d;
      const pluginManager = window.app.plugins;
      try {
        const settings = shouldUsePeriodicNotesSettings("yearly") && ((_b = (_a = pluginManager.getPlugin("periodic-notes")) == null ? void 0 : _a.settings) == null ? void 0 : _b.yearly) || {};
        return {
          format: settings.format || DEFAULT_YEARLY_NOTE_FORMAT,
          folder: ((_c = settings.folder) == null ? void 0 : _c.trim()) || "",
          template: ((_d = settings.template) == null ? void 0 : _d.trim()) || ""
        };
      } catch (err) {
        console.info("No custom yearly note settings found!", err);
      }
    }
    function join(...partSegments) {
      let parts = [];
      for (let i = 0, l = partSegments.length; i < l; i++) {
        parts = parts.concat(partSegments[i].split("/"));
      }
      const newParts = [];
      for (let i = 0, l = parts.length; i < l; i++) {
        const part = parts[i];
        if (!part || part === ".")
          continue;
        else
          newParts.push(part);
      }
      if (parts[0] === "")
        newParts.unshift("");
      return newParts.join("/");
    }
    function basename3(fullPath) {
      let base = fullPath.substring(fullPath.lastIndexOf("/") + 1);
      if (base.lastIndexOf(".") != -1)
        base = base.substring(0, base.lastIndexOf("."));
      return base;
    }
    async function ensureFolderExists(path) {
      const dirs = path.replace(/\\/g, "/").split("/");
      dirs.pop();
      if (dirs.length) {
        const dir = join(...dirs);
        if (!window.app.vault.getAbstractFileByPath(dir)) {
          await window.app.vault.createFolder(dir);
        }
      }
    }
    async function getNotePath(directory, filename) {
      if (!filename.endsWith(".md")) {
        filename += ".md";
      }
      const path = obsidian.normalizePath(join(directory, filename));
      await ensureFolderExists(path);
      return path;
    }
    async function getTemplateInfo(template) {
      const { metadataCache, vault } = window.app;
      const templatePath = obsidian.normalizePath(template);
      if (templatePath === "/") {
        return Promise.resolve(["", null]);
      }
      try {
        const templateFile = metadataCache.getFirstLinkpathDest(templatePath, "");
        const contents = await vault.cachedRead(templateFile);
        const IFoldInfo = window.app.foldManager.load(templateFile);
        return [contents, IFoldInfo];
      } catch (err) {
        console.error(`Failed to read the daily note template '${templatePath}'`, err);
        new obsidian.Notice("Failed to read the daily note template");
        return ["", null];
      }
    }
    function getDateUID(date, granularity = "day") {
      const ts = date.clone().startOf(granularity).format();
      return `${granularity}-${ts}`;
    }
    function removeEscapedCharacters(format) {
      return format.replace(/\[[^\]]*\]/g, "");
    }
    function isFormatAmbiguous(format, granularity) {
      if (granularity === "week") {
        const cleanFormat = removeEscapedCharacters(format);
        return /w{1,2}/i.test(cleanFormat) && (/M{1,4}/.test(cleanFormat) || /D{1,4}/.test(cleanFormat));
      }
      return false;
    }
    function getDateFromFile(file, granularity) {
      return getDateFromFilename(file.basename, granularity);
    }
    function getDateFromPath(path, granularity) {
      return getDateFromFilename(basename3(path), granularity);
    }
    function getDateFromFilename(filename, granularity) {
      const getSettings = {
        day: getDailyNoteSettings,
        week: getWeeklyNoteSettings,
        month: getMonthlyNoteSettings,
        quarter: getQuarterlyNoteSettings,
        year: getYearlyNoteSettings
      };
      const format = getSettings[granularity]().format.split("/").pop();
      const noteDate = window.moment(filename, format, true);
      if (!noteDate.isValid()) {
        return null;
      }
      if (isFormatAmbiguous(format, granularity)) {
        if (granularity === "week") {
          const cleanFormat = removeEscapedCharacters(format);
          if (/w{1,2}/i.test(cleanFormat)) {
            return window.moment(
              filename,
              // If format contains week, remove day & month formatting
              format.replace(/M{1,4}/g, "").replace(/D{1,4}/g, ""),
              false
            );
          }
        }
      }
      return noteDate;
    }
    var DailyNotesFolderMissingError = class extends Error {
    };
    async function createDailyNote2(date) {
      const app = window.app;
      const { vault } = app;
      const moment4 = window.moment;
      const { template, format, folder } = getDailyNoteSettings();
      const [templateContents, IFoldInfo] = await getTemplateInfo(template);
      const filename = date.format(format);
      const normalizedPath = await getNotePath(folder, filename);
      try {
        const createdFile = await vault.create(normalizedPath, templateContents.replace(/{{\s*date\s*}}/gi, filename).replace(/{{\s*time\s*}}/gi, moment4().format("HH:mm")).replace(/{{\s*title\s*}}/gi, filename).replace(/{{\s*(date|time)\s*(([+-]\d+)([yqmwdhs]))?\s*(:.+?)?}}/gi, (_, _timeOrDate, calc, timeDelta, unit, momentFormat) => {
          const now = moment4();
          const currentDate = date.clone().set({
            hour: now.get("hour"),
            minute: now.get("minute"),
            second: now.get("second")
          });
          if (calc) {
            currentDate.add(parseInt(timeDelta, 10), unit);
          }
          if (momentFormat) {
            return currentDate.format(momentFormat.substring(1).trim());
          }
          return currentDate.format(format);
        }).replace(/{{\s*yesterday\s*}}/gi, date.clone().subtract(1, "day").format(format)).replace(/{{\s*tomorrow\s*}}/gi, date.clone().add(1, "d").format(format)));
        app.foldManager.save(createdFile, IFoldInfo);
        return createdFile;
      } catch (err) {
        console.error(`Failed to create file: '${normalizedPath}'`, err);
        new obsidian.Notice("Unable to create new file.");
      }
    }
    function getDailyNote2(date, dailyNotes) {
      var _a;
      return (_a = dailyNotes[getDateUID(date, "day")]) != null ? _a : null;
    }
    function getAllDailyNotes2() {
      const { vault } = window.app;
      const { folder } = getDailyNoteSettings();
      const dailyNotesFolder = vault.getAbstractFileByPath(obsidian.normalizePath(folder));
      if (!dailyNotesFolder) {
        throw new DailyNotesFolderMissingError("Failed to find daily notes folder");
      }
      const dailyNotes = {};
      obsidian.Vault.recurseChildren(dailyNotesFolder, (note) => {
        if (note instanceof obsidian.TFile) {
          const date = getDateFromFile(note, "day");
          if (date) {
            const dateString = getDateUID(date, "day");
            dailyNotes[dateString] = note;
          }
        }
      });
      return dailyNotes;
    }
    var WeeklyNotesFolderMissingError = class extends Error {
    };
    function getDaysOfWeek() {
      const { moment: moment4 } = window;
      let weekStart = moment4.localeData()._week.dow;
      const daysOfWeek = [
        "sunday",
        "monday",
        "tuesday",
        "wednesday",
        "thursday",
        "friday",
        "saturday"
      ];
      while (weekStart) {
        daysOfWeek.push(daysOfWeek.shift());
        weekStart--;
      }
      return daysOfWeek;
    }
    function getDayOfWeekNumericalValue(dayOfWeekName) {
      return getDaysOfWeek().indexOf(dayOfWeekName.toLowerCase());
    }
    async function createWeeklyNote(date) {
      const { vault } = window.app;
      const { template, format, folder } = getWeeklyNoteSettings();
      const [templateContents, IFoldInfo] = await getTemplateInfo(template);
      const filename = date.format(format);
      const normalizedPath = await getNotePath(folder, filename);
      try {
        const createdFile = await vault.create(normalizedPath, templateContents.replace(/{{\s*(date|time)\s*(([+-]\d+)([yqmwdhs]))?\s*(:.+?)?}}/gi, (_, _timeOrDate, calc, timeDelta, unit, momentFormat) => {
          const now = window.moment();
          const currentDate = date.clone().set({
            hour: now.get("hour"),
            minute: now.get("minute"),
            second: now.get("second")
          });
          if (calc) {
            currentDate.add(parseInt(timeDelta, 10), unit);
          }
          if (momentFormat) {
            return currentDate.format(momentFormat.substring(1).trim());
          }
          return currentDate.format(format);
        }).replace(/{{\s*title\s*}}/gi, filename).replace(/{{\s*time\s*}}/gi, window.moment().format("HH:mm")).replace(/{{\s*(sunday|monday|tuesday|wednesday|thursday|friday|saturday)\s*:(.*?)}}/gi, (_, dayOfWeek, momentFormat) => {
          const day = getDayOfWeekNumericalValue(dayOfWeek);
          return date.weekday(day).format(momentFormat.trim());
        }));
        window.app.foldManager.save(createdFile, IFoldInfo);
        return createdFile;
      } catch (err) {
        console.error(`Failed to create file: '${normalizedPath}'`, err);
        new obsidian.Notice("Unable to create new file.");
      }
    }
    function getWeeklyNote(date, weeklyNotes) {
      var _a;
      return (_a = weeklyNotes[getDateUID(date, "week")]) != null ? _a : null;
    }
    function getAllWeeklyNotes() {
      const weeklyNotes = {};
      if (!appHasWeeklyNotesPluginLoaded()) {
        return weeklyNotes;
      }
      const { vault } = window.app;
      const { folder } = getWeeklyNoteSettings();
      const weeklyNotesFolder = vault.getAbstractFileByPath(obsidian.normalizePath(folder));
      if (!weeklyNotesFolder) {
        throw new WeeklyNotesFolderMissingError("Failed to find weekly notes folder");
      }
      obsidian.Vault.recurseChildren(weeklyNotesFolder, (note) => {
        if (note instanceof obsidian.TFile) {
          const date = getDateFromFile(note, "week");
          if (date) {
            const dateString = getDateUID(date, "week");
            weeklyNotes[dateString] = note;
          }
        }
      });
      return weeklyNotes;
    }
    var MonthlyNotesFolderMissingError = class extends Error {
    };
    async function createMonthlyNote(date) {
      const { vault } = window.app;
      const { template, format, folder } = getMonthlyNoteSettings();
      const [templateContents, IFoldInfo] = await getTemplateInfo(template);
      const filename = date.format(format);
      const normalizedPath = await getNotePath(folder, filename);
      try {
        const createdFile = await vault.create(normalizedPath, templateContents.replace(/{{\s*(date|time)\s*(([+-]\d+)([yqmwdhs]))?\s*(:.+?)?}}/gi, (_, _timeOrDate, calc, timeDelta, unit, momentFormat) => {
          const now = window.moment();
          const currentDate = date.clone().set({
            hour: now.get("hour"),
            minute: now.get("minute"),
            second: now.get("second")
          });
          if (calc) {
            currentDate.add(parseInt(timeDelta, 10), unit);
          }
          if (momentFormat) {
            return currentDate.format(momentFormat.substring(1).trim());
          }
          return currentDate.format(format);
        }).replace(/{{\s*date\s*}}/gi, filename).replace(/{{\s*time\s*}}/gi, window.moment().format("HH:mm")).replace(/{{\s*title\s*}}/gi, filename));
        window.app.foldManager.save(createdFile, IFoldInfo);
        return createdFile;
      } catch (err) {
        console.error(`Failed to create file: '${normalizedPath}'`, err);
        new obsidian.Notice("Unable to create new file.");
      }
    }
    function getMonthlyNote(date, monthlyNotes) {
      var _a;
      return (_a = monthlyNotes[getDateUID(date, "month")]) != null ? _a : null;
    }
    function getAllMonthlyNotes() {
      const monthlyNotes = {};
      if (!appHasMonthlyNotesPluginLoaded()) {
        return monthlyNotes;
      }
      const { vault } = window.app;
      const { folder } = getMonthlyNoteSettings();
      const monthlyNotesFolder = vault.getAbstractFileByPath(obsidian.normalizePath(folder));
      if (!monthlyNotesFolder) {
        throw new MonthlyNotesFolderMissingError("Failed to find monthly notes folder");
      }
      obsidian.Vault.recurseChildren(monthlyNotesFolder, (note) => {
        if (note instanceof obsidian.TFile) {
          const date = getDateFromFile(note, "month");
          if (date) {
            const dateString = getDateUID(date, "month");
            monthlyNotes[dateString] = note;
          }
        }
      });
      return monthlyNotes;
    }
    var QuarterlyNotesFolderMissingError = class extends Error {
    };
    async function createQuarterlyNote(date) {
      const { vault } = window.app;
      const { template, format, folder } = getQuarterlyNoteSettings();
      const [templateContents, IFoldInfo] = await getTemplateInfo(template);
      const filename = date.format(format);
      const normalizedPath = await getNotePath(folder, filename);
      try {
        const createdFile = await vault.create(normalizedPath, templateContents.replace(/{{\s*(date|time)\s*(([+-]\d+)([yqmwdhs]))?\s*(:.+?)?}}/gi, (_, _timeOrDate, calc, timeDelta, unit, momentFormat) => {
          const now = window.moment();
          const currentDate = date.clone().set({
            hour: now.get("hour"),
            minute: now.get("minute"),
            second: now.get("second")
          });
          if (calc) {
            currentDate.add(parseInt(timeDelta, 10), unit);
          }
          if (momentFormat) {
            return currentDate.format(momentFormat.substring(1).trim());
          }
          return currentDate.format(format);
        }).replace(/{{\s*date\s*}}/gi, filename).replace(/{{\s*time\s*}}/gi, window.moment().format("HH:mm")).replace(/{{\s*title\s*}}/gi, filename));
        window.app.foldManager.save(createdFile, IFoldInfo);
        return createdFile;
      } catch (err) {
        console.error(`Failed to create file: '${normalizedPath}'`, err);
        new obsidian.Notice("Unable to create new file.");
      }
    }
    function getQuarterlyNote(date, quarterly) {
      var _a;
      return (_a = quarterly[getDateUID(date, "quarter")]) != null ? _a : null;
    }
    function getAllQuarterlyNotes() {
      const quarterly = {};
      if (!appHasQuarterlyNotesPluginLoaded()) {
        return quarterly;
      }
      const { vault } = window.app;
      const { folder } = getQuarterlyNoteSettings();
      const quarterlyFolder = vault.getAbstractFileByPath(obsidian.normalizePath(folder));
      if (!quarterlyFolder) {
        throw new QuarterlyNotesFolderMissingError("Failed to find quarterly notes folder");
      }
      obsidian.Vault.recurseChildren(quarterlyFolder, (note) => {
        if (note instanceof obsidian.TFile) {
          const date = getDateFromFile(note, "quarter");
          if (date) {
            const dateString = getDateUID(date, "quarter");
            quarterly[dateString] = note;
          }
        }
      });
      return quarterly;
    }
    var YearlyNotesFolderMissingError = class extends Error {
    };
    async function createYearlyNote(date) {
      const { vault } = window.app;
      const { template, format, folder } = getYearlyNoteSettings();
      const [templateContents, IFoldInfo] = await getTemplateInfo(template);
      const filename = date.format(format);
      const normalizedPath = await getNotePath(folder, filename);
      try {
        const createdFile = await vault.create(normalizedPath, templateContents.replace(/{{\s*(date|time)\s*(([+-]\d+)([yqmwdhs]))?\s*(:.+?)?}}/gi, (_, _timeOrDate, calc, timeDelta, unit, momentFormat) => {
          const now = window.moment();
          const currentDate = date.clone().set({
            hour: now.get("hour"),
            minute: now.get("minute"),
            second: now.get("second")
          });
          if (calc) {
            currentDate.add(parseInt(timeDelta, 10), unit);
          }
          if (momentFormat) {
            return currentDate.format(momentFormat.substring(1).trim());
          }
          return currentDate.format(format);
        }).replace(/{{\s*date\s*}}/gi, filename).replace(/{{\s*time\s*}}/gi, window.moment().format("HH:mm")).replace(/{{\s*title\s*}}/gi, filename));
        window.app.foldManager.save(createdFile, IFoldInfo);
        return createdFile;
      } catch (err) {
        console.error(`Failed to create file: '${normalizedPath}'`, err);
        new obsidian.Notice("Unable to create new file.");
      }
    }
    function getYearlyNote(date, yearlyNotes) {
      var _a;
      return (_a = yearlyNotes[getDateUID(date, "year")]) != null ? _a : null;
    }
    function getAllYearlyNotes() {
      const yearlyNotes = {};
      if (!appHasYearlyNotesPluginLoaded()) {
        return yearlyNotes;
      }
      const { vault } = window.app;
      const { folder } = getYearlyNoteSettings();
      const yearlyNotesFolder = vault.getAbstractFileByPath(obsidian.normalizePath(folder));
      if (!yearlyNotesFolder) {
        throw new YearlyNotesFolderMissingError("Failed to find yearly notes folder");
      }
      obsidian.Vault.recurseChildren(yearlyNotesFolder, (note) => {
        if (note instanceof obsidian.TFile) {
          const date = getDateFromFile(note, "year");
          if (date) {
            const dateString = getDateUID(date, "year");
            yearlyNotes[dateString] = note;
          }
        }
      });
      return yearlyNotes;
    }
    function appHasDailyNotesPluginLoaded() {
      var _a, _b;
      const { app } = window;
      const dailyNotesPlugin = app.internalPlugins.plugins["daily-notes"];
      if (dailyNotesPlugin && dailyNotesPlugin.enabled) {
        return true;
      }
      const periodicNotes = app.plugins.getPlugin("periodic-notes");
      return periodicNotes && ((_b = (_a = periodicNotes.settings) == null ? void 0 : _a.daily) == null ? void 0 : _b.enabled);
    }
    function appHasWeeklyNotesPluginLoaded() {
      var _a, _b;
      const { app } = window;
      if (app.plugins.getPlugin("calendar")) {
        return true;
      }
      const periodicNotes = app.plugins.getPlugin("periodic-notes");
      return periodicNotes && ((_b = (_a = periodicNotes.settings) == null ? void 0 : _a.weekly) == null ? void 0 : _b.enabled);
    }
    function appHasMonthlyNotesPluginLoaded() {
      var _a, _b;
      const { app } = window;
      const periodicNotes = app.plugins.getPlugin("periodic-notes");
      return periodicNotes && ((_b = (_a = periodicNotes.settings) == null ? void 0 : _a.monthly) == null ? void 0 : _b.enabled);
    }
    function appHasQuarterlyNotesPluginLoaded() {
      var _a, _b;
      const { app } = window;
      const periodicNotes = app.plugins.getPlugin("periodic-notes");
      return periodicNotes && ((_b = (_a = periodicNotes.settings) == null ? void 0 : _a.quarterly) == null ? void 0 : _b.enabled);
    }
    function appHasYearlyNotesPluginLoaded() {
      var _a, _b;
      const { app } = window;
      const periodicNotes = app.plugins.getPlugin("periodic-notes");
      return periodicNotes && ((_b = (_a = periodicNotes.settings) == null ? void 0 : _a.yearly) == null ? void 0 : _b.enabled);
    }
    function getPeriodicNoteSettings(granularity) {
      const getSettings = {
        day: getDailyNoteSettings,
        week: getWeeklyNoteSettings,
        month: getMonthlyNoteSettings,
        quarter: getQuarterlyNoteSettings,
        year: getYearlyNoteSettings
      }[granularity];
      return getSettings();
    }
    function createPeriodicNote(granularity, date) {
      const createFn = {
        day: createDailyNote2,
        month: createMonthlyNote,
        week: createWeeklyNote
      };
      return createFn[granularity](date);
    }
    exports.DEFAULT_DAILY_NOTE_FORMAT = DEFAULT_DAILY_NOTE_FORMAT;
    exports.DEFAULT_MONTHLY_NOTE_FORMAT = DEFAULT_MONTHLY_NOTE_FORMAT;
    exports.DEFAULT_QUARTERLY_NOTE_FORMAT = DEFAULT_QUARTERLY_NOTE_FORMAT;
    exports.DEFAULT_WEEKLY_NOTE_FORMAT = DEFAULT_WEEKLY_NOTE_FORMAT;
    exports.DEFAULT_YEARLY_NOTE_FORMAT = DEFAULT_YEARLY_NOTE_FORMAT;
    exports.appHasDailyNotesPluginLoaded = appHasDailyNotesPluginLoaded;
    exports.appHasMonthlyNotesPluginLoaded = appHasMonthlyNotesPluginLoaded;
    exports.appHasQuarterlyNotesPluginLoaded = appHasQuarterlyNotesPluginLoaded;
    exports.appHasWeeklyNotesPluginLoaded = appHasWeeklyNotesPluginLoaded;
    exports.appHasYearlyNotesPluginLoaded = appHasYearlyNotesPluginLoaded;
    exports.createDailyNote = createDailyNote2;
    exports.createMonthlyNote = createMonthlyNote;
    exports.createPeriodicNote = createPeriodicNote;
    exports.createQuarterlyNote = createQuarterlyNote;
    exports.createWeeklyNote = createWeeklyNote;
    exports.createYearlyNote = createYearlyNote;
    exports.getAllDailyNotes = getAllDailyNotes2;
    exports.getAllMonthlyNotes = getAllMonthlyNotes;
    exports.getAllQuarterlyNotes = getAllQuarterlyNotes;
    exports.getAllWeeklyNotes = getAllWeeklyNotes;
    exports.getAllYearlyNotes = getAllYearlyNotes;
    exports.getDailyNote = getDailyNote2;
    exports.getDailyNoteSettings = getDailyNoteSettings;
    exports.getDateFromFile = getDateFromFile;
    exports.getDateFromPath = getDateFromPath;
    exports.getDateUID = getDateUID;
    exports.getMonthlyNote = getMonthlyNote;
    exports.getMonthlyNoteSettings = getMonthlyNoteSettings;
    exports.getPeriodicNoteSettings = getPeriodicNoteSettings;
    exports.getQuarterlyNote = getQuarterlyNote;
    exports.getQuarterlyNoteSettings = getQuarterlyNoteSettings;
    exports.getTemplateInfo = getTemplateInfo;
    exports.getWeeklyNote = getWeeklyNote;
    exports.getWeeklyNoteSettings = getWeeklyNoteSettings;
    exports.getYearlyNote = getYearlyNote;
    exports.getYearlyNoteSettings = getYearlyNoteSettings;
  }
});

// node_modules/.pnpm/@telegraf+entity@0.5.0/node_modules/@telegraf/entity/script/serialisers.js
var require_serialisers = __commonJS({
  "node_modules/.pnpm/@telegraf+entity@0.5.0/node_modules/@telegraf/entity/script/serialisers.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.MarkdownV2 = exports.HTML = void 0;
    var HTML = (match2, node) => {
      switch (node == null ? void 0 : node.type) {
        case "bold":
          return `<b>${match2}</b>`;
        case "italic":
          return `<i>${match2}</i>`;
        case "underline":
          return `<u>${match2}</u>`;
        case "strikethrough":
          return `<del>${match2}</del>`;
        case "code":
          return `<code>${match2}</code>`;
        case "pre":
          if (node.language)
            return `<pre><code class="language-${node.language}">${match2}</code></pre>`;
          return `<pre>${match2}</pre>`;
        case "spoiler":
          return `<span class="tg-spoiler">${match2}</span>`;
        case "url":
          return `<a href="${node.text}">${match2}</a>`;
        case "text_link":
          return `<a href="${node.url}">${match2}</a>`;
        case "text_mention":
          return `<a href="tg://user?id=${node.user.id}">${match2}</a>`;
        case "blockquote":
          return `<blockquote>${match2}</blockquote>`;
        case "mention":
        case "custom_emoji":
        case "hashtag":
        case "cashtag":
        case "bot_command":
        case "phone_number":
        case "email":
        default:
          return match2;
      }
    };
    exports.HTML = HTML;
    function MarkdownV2(match2, node) {
      switch (node == null ? void 0 : node.type) {
        case "bold":
          return `*${match2}*`;
        case "italic":
          return `_${match2}_`;
        case "underline":
          return `__${match2}__`;
        case "strikethrough":
          return `~${match2}~`;
        case "code":
          return `\`${match2}\``;
        case "pre":
          if (node.language)
            return "```" + node.language + "\n" + match2 + "\n```";
          return "```\n" + match2 + "\n```";
        case "spoiler":
          return `||${match2}||`;
        case "url":
          return match2;
        case "text_link":
          return `[${match2}](${node.url})`;
        case "text_mention":
          return `[${match2}](tg://user?id=${node.user.id})`;
        case "blockquote":
          return `${match2.split("\n").map((line) => `>${line}`).join("\n")}`;
        case "mention":
        case "custom_emoji":
        case "hashtag":
        case "cashtag":
        case "bot_command":
        case "phone_number":
        case "email":
        default:
          return match2;
      }
    }
    exports.MarkdownV2 = MarkdownV2;
  }
});

// node_modules/.pnpm/@telegraf+entity@0.5.0/node_modules/@telegraf/entity/script/escapers.js
var require_escapers = __commonJS({
  "node_modules/.pnpm/@telegraf+entity@0.5.0/node_modules/@telegraf/entity/script/escapers.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.MarkdownV2 = exports.HTML = void 0;
    exports.HTML = (() => {
      const escapables = {
        "<": "&lt;",
        ">": "&gt;",
        "&": "&amp;"
      };
      const toEscape = /<|>|&/g;
      return (s2) => s2.replace(toEscape, (r) => escapables[r] || r);
    })();
    exports.MarkdownV2 = (() => {
      const escapables = {
        "_": "\\_",
        "*": "\\*",
        "[": "\\[",
        "]": "\\]",
        "(": "\\(",
        ")": "\\)",
        "~": "\\~",
        "`": "\\`",
        ">": "\\>",
        "#": "\\#",
        "+": "\\+",
        "-": "\\-",
        "=": "\\=",
        "|": "\\|",
        "{": "\\{",
        "}": "\\}",
        ".": "\\.",
        "!": "\\!"
      };
      const toEscape = new RegExp("[" + Object.values(escapables).join("") + "]", "g");
      return (s2) => s2.replace(toEscape, (r) => escapables[r] || r);
    })();
  }
});

// node_modules/.pnpm/@telegraf+entity@0.5.0/node_modules/@telegraf/entity/script/mod.js
var require_mod = __commonJS({
  "node_modules/.pnpm/@telegraf+entity@0.5.0/node_modules/@telegraf/entity/script/mod.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m2, k, k2) {
      if (k2 === void 0)
        k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m2, k);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m2[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m2, k, k2) {
      if (k2 === void 0)
        k2 = k;
      o[k2] = m2[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || function(mod) {
      if (mod && mod.__esModule)
        return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod)
          if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
            __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.toMarkdownV2 = exports.toHTML = exports.serialiseWith = exports.escapers = exports.serialisers = exports.toTree = void 0;
    var serialisers = __importStar(require_serialisers());
    exports.serialisers = serialisers;
    var escapers2 = __importStar(require_escapers());
    exports.escapers = escapers2;
    var TYPE_PRIORITY = {
      mention: 50,
      hashtag: 50,
      bot_command: 50,
      url: 50,
      email: 50,
      bold: 90,
      italic: 91,
      code: 20,
      pre: 11,
      text_link: 49,
      text_mention: 49,
      cashtag: 50,
      phone_number: 50,
      underline: 92,
      strikethrough: 93,
      blockquote: 0,
      spoiler: 94,
      custom_emoji: 99
    };
    function findChildren(fromEntityIndex, parent, entities) {
      const ret = [];
      for (let i = fromEntityIndex + 1; i < entities.length; i++) {
        const entity = entities[i];
        if (entity.offset + entity.length > parent.offset + parent.length)
          break;
        ret.push(entity);
      }
      return ret;
    }
    var ends = (entity) => entity.offset + entity.length;
    function toTree(msg, offset = 0, upto = Infinity) {
      var _a;
      if (!((_a = msg.entities) == null ? void 0 : _a.length))
        return [msg.text.slice(offset, upto)];
      const nodes = [];
      let last = offset;
      let i = 0;
      while (i < msg.entities.length) {
        const entity = msg.entities[i];
        if (last < entity.offset) {
          nodes.push(msg.text.slice(last, entity.offset));
          last = entity.offset;
        }
        const children = findChildren(i, entity, msg.entities);
        const node = {
          ...entity,
          text: msg.text.slice(entity.offset, ends(entity)),
          children: toTree({ text: msg.text, entities: children }, entity.offset, ends(entity))
        };
        last = ends(node);
        nodes.push(node);
        i += children.length + 1;
      }
      if (last < upto) {
        const final = msg.text.slice(last, upto);
        if (final)
          nodes.push(final);
      }
      return nodes;
    }
    exports.toTree = toTree;
    function serialse(tree, serialiser, escaper) {
      let ret = "";
      for (const node of tree) {
        if (typeof node === "string")
          ret += escaper(node);
        else
          ret += serialiser(serialse(node.children, serialiser, escaper), node);
      }
      return ret;
    }
    var serialiseWith2 = (serialiser, escaper) => (message) => {
      const msg = "text" in message ? message : { text: message.caption || "", entities: message.caption_entities };
      if (!msg.entities || msg.entities.length === 0)
        return serialiser(msg.text);
      const entities = msg.entities.sort((a, b) => {
        if (a.offset < b.offset)
          return -1;
        if (a.offset > b.offset)
          return 1;
        if (a.length > b.length)
          return -1;
        if (a.length < b.length)
          return 1;
        const a_priority = TYPE_PRIORITY[a.type];
        const b_priority = TYPE_PRIORITY[b.type];
        if (a_priority < b_priority)
          return -1;
        if (a_priority > b_priority)
          return 1;
        return 0;
      });
      return serialse(toTree({ text: msg.text, entities }), serialiser, escaper);
    };
    exports.serialiseWith = serialiseWith2;
    var toHTML = serialiseWith2(serialisers.HTML, escapers2.HTML);
    exports.toHTML = toHTML;
    var toMarkdownV22 = serialiseWith2(serialisers.MarkdownV2, escapers2.MarkdownV2);
    exports.toMarkdownV2 = toMarkdownV22;
  }
});

// node_modules/.pnpm/mustache@4.1.0/node_modules/mustache/mustache.js
var require_mustache = __commonJS({
  "node_modules/.pnpm/mustache@4.1.0/node_modules/mustache/mustache.js"(exports, module2) {
    (function(global, factory) {
      typeof exports === "object" && typeof module2 !== "undefined" ? module2.exports = factory() : typeof define === "function" && define.amd ? define(factory) : (global = global || self, global.Mustache = factory());
    })(exports, function() {
      "use strict";
      var objectToString = Object.prototype.toString;
      var isArray = Array.isArray || function isArrayPolyfill(object) {
        return objectToString.call(object) === "[object Array]";
      };
      function isFunction(object) {
        return typeof object === "function";
      }
      function typeStr(obj) {
        return isArray(obj) ? "array" : typeof obj;
      }
      function escapeRegExp(string) {
        return string.replace(/[\-\[\]{}()*+?.,\\\^$|#\s]/g, "\\$&");
      }
      function hasProperty(obj, propName) {
        return obj != null && typeof obj === "object" && propName in obj;
      }
      function primitiveHasOwnProperty(primitive, propName) {
        return primitive != null && typeof primitive !== "object" && primitive.hasOwnProperty && primitive.hasOwnProperty(propName);
      }
      var regExpTest = RegExp.prototype.test;
      function testRegExp(re, string) {
        return regExpTest.call(re, string);
      }
      var nonSpaceRe = /\S/;
      function isWhitespace(string) {
        return !testRegExp(nonSpaceRe, string);
      }
      var entityMap = {
        "&": "&amp;",
        "<": "&lt;",
        ">": "&gt;",
        '"': "&quot;",
        "'": "&#39;",
        "/": "&#x2F;",
        "`": "&#x60;",
        "=": "&#x3D;"
      };
      function escapeHtml(string) {
        return String(string).replace(/[&<>"'`=\/]/g, function fromEntityMap(s2) {
          return entityMap[s2];
        });
      }
      var whiteRe = /\s*/;
      var spaceRe = /\s+/;
      var equalsRe = /\s*=/;
      var curlyRe = /\s*\}/;
      var tagRe = /#|\^|\/|>|\{|&|=|!/;
      function parseTemplate(template, tags) {
        if (!template)
          return [];
        var lineHasNonSpace = false;
        var sections = [];
        var tokens = [];
        var spaces = [];
        var hasTag = false;
        var nonSpace = false;
        var indentation = "";
        var tagIndex = 0;
        function stripSpace() {
          if (hasTag && !nonSpace) {
            while (spaces.length)
              delete tokens[spaces.pop()];
          } else {
            spaces = [];
          }
          hasTag = false;
          nonSpace = false;
        }
        var openingTagRe, closingTagRe, closingCurlyRe;
        function compileTags(tagsToCompile) {
          if (typeof tagsToCompile === "string")
            tagsToCompile = tagsToCompile.split(spaceRe, 2);
          if (!isArray(tagsToCompile) || tagsToCompile.length !== 2)
            throw new Error("Invalid tags: " + tagsToCompile);
          openingTagRe = new RegExp(escapeRegExp(tagsToCompile[0]) + "\\s*");
          closingTagRe = new RegExp("\\s*" + escapeRegExp(tagsToCompile[1]));
          closingCurlyRe = new RegExp("\\s*" + escapeRegExp("}" + tagsToCompile[1]));
        }
        compileTags(tags || mustache.tags);
        var scanner = new Scanner(template);
        var start, type, value, chr, token, openSection;
        while (!scanner.eos()) {
          start = scanner.pos;
          value = scanner.scanUntil(openingTagRe);
          if (value) {
            for (var i = 0, valueLength = value.length; i < valueLength; ++i) {
              chr = value.charAt(i);
              if (isWhitespace(chr)) {
                spaces.push(tokens.length);
                indentation += chr;
              } else {
                nonSpace = true;
                lineHasNonSpace = true;
                indentation += " ";
              }
              tokens.push(["text", chr, start, start + 1]);
              start += 1;
              if (chr === "\n") {
                stripSpace();
                indentation = "";
                tagIndex = 0;
                lineHasNonSpace = false;
              }
            }
          }
          if (!scanner.scan(openingTagRe))
            break;
          hasTag = true;
          type = scanner.scan(tagRe) || "name";
          scanner.scan(whiteRe);
          if (type === "=") {
            value = scanner.scanUntil(equalsRe);
            scanner.scan(equalsRe);
            scanner.scanUntil(closingTagRe);
          } else if (type === "{") {
            value = scanner.scanUntil(closingCurlyRe);
            scanner.scan(curlyRe);
            scanner.scanUntil(closingTagRe);
            type = "&";
          } else {
            value = scanner.scanUntil(closingTagRe);
          }
          if (!scanner.scan(closingTagRe))
            throw new Error("Unclosed tag at " + scanner.pos);
          if (type == ">") {
            token = [type, value, start, scanner.pos, indentation, tagIndex, lineHasNonSpace];
          } else {
            token = [type, value, start, scanner.pos];
          }
          tagIndex++;
          tokens.push(token);
          if (type === "#" || type === "^") {
            sections.push(token);
          } else if (type === "/") {
            openSection = sections.pop();
            if (!openSection)
              throw new Error('Unopened section "' + value + '" at ' + start);
            if (openSection[1] !== value)
              throw new Error('Unclosed section "' + openSection[1] + '" at ' + start);
          } else if (type === "name" || type === "{" || type === "&") {
            nonSpace = true;
          } else if (type === "=") {
            compileTags(value);
          }
        }
        stripSpace();
        openSection = sections.pop();
        if (openSection)
          throw new Error('Unclosed section "' + openSection[1] + '" at ' + scanner.pos);
        return nestTokens(squashTokens(tokens));
      }
      function squashTokens(tokens) {
        var squashedTokens = [];
        var token, lastToken;
        for (var i = 0, numTokens = tokens.length; i < numTokens; ++i) {
          token = tokens[i];
          if (token) {
            if (token[0] === "text" && lastToken && lastToken[0] === "text") {
              lastToken[1] += token[1];
              lastToken[3] = token[3];
            } else {
              squashedTokens.push(token);
              lastToken = token;
            }
          }
        }
        return squashedTokens;
      }
      function nestTokens(tokens) {
        var nestedTokens = [];
        var collector = nestedTokens;
        var sections = [];
        var token, section;
        for (var i = 0, numTokens = tokens.length; i < numTokens; ++i) {
          token = tokens[i];
          switch (token[0]) {
            case "#":
            case "^":
              collector.push(token);
              sections.push(token);
              collector = token[4] = [];
              break;
            case "/":
              section = sections.pop();
              section[5] = token[2];
              collector = sections.length > 0 ? sections[sections.length - 1][4] : nestedTokens;
              break;
            default:
              collector.push(token);
          }
        }
        return nestedTokens;
      }
      function Scanner(string) {
        this.string = string;
        this.tail = string;
        this.pos = 0;
      }
      Scanner.prototype.eos = function eos() {
        return this.tail === "";
      };
      Scanner.prototype.scan = function scan(re) {
        var match2 = this.tail.match(re);
        if (!match2 || match2.index !== 0)
          return "";
        var string = match2[0];
        this.tail = this.tail.substring(string.length);
        this.pos += string.length;
        return string;
      };
      Scanner.prototype.scanUntil = function scanUntil(re) {
        var index = this.tail.search(re), match2;
        switch (index) {
          case -1:
            match2 = this.tail;
            this.tail = "";
            break;
          case 0:
            match2 = "";
            break;
          default:
            match2 = this.tail.substring(0, index);
            this.tail = this.tail.substring(index);
        }
        this.pos += match2.length;
        return match2;
      };
      function Context2(view, parentContext) {
        this.view = view;
        this.cache = { ".": this.view };
        this.parent = parentContext;
      }
      Context2.prototype.push = function push(view) {
        return new Context2(view, this);
      };
      Context2.prototype.lookup = function lookup(name) {
        var cache = this.cache;
        var value;
        if (cache.hasOwnProperty(name)) {
          value = cache[name];
        } else {
          var context = this, intermediateValue, names, index, lookupHit = false;
          while (context) {
            if (name.indexOf(".") > 0) {
              intermediateValue = context.view;
              names = name.split(".");
              index = 0;
              while (intermediateValue != null && index < names.length) {
                if (index === names.length - 1)
                  lookupHit = hasProperty(intermediateValue, names[index]) || primitiveHasOwnProperty(intermediateValue, names[index]);
                intermediateValue = intermediateValue[names[index++]];
              }
            } else {
              intermediateValue = context.view[name];
              lookupHit = hasProperty(context.view, name);
            }
            if (lookupHit) {
              value = intermediateValue;
              break;
            }
            context = context.parent;
          }
          cache[name] = value;
        }
        if (isFunction(value))
          value = value.call(this.view);
        return value;
      };
      function Writer() {
        this.templateCache = {
          _cache: {},
          set: function set(key, value) {
            this._cache[key] = value;
          },
          get: function get(key) {
            return this._cache[key];
          },
          clear: function clear() {
            this._cache = {};
          }
        };
      }
      Writer.prototype.clearCache = function clearCache() {
        if (typeof this.templateCache !== "undefined") {
          this.templateCache.clear();
        }
      };
      Writer.prototype.parse = function parse3(template, tags) {
        var cache = this.templateCache;
        var cacheKey = template + ":" + (tags || mustache.tags).join(":");
        var isCacheEnabled = typeof cache !== "undefined";
        var tokens = isCacheEnabled ? cache.get(cacheKey) : void 0;
        if (tokens == void 0) {
          tokens = parseTemplate(template, tags);
          isCacheEnabled && cache.set(cacheKey, tokens);
        }
        return tokens;
      };
      Writer.prototype.render = function render2(template, view, partials, config2) {
        var tags = this.getConfigTags(config2);
        var tokens = this.parse(template, tags);
        var context = view instanceof Context2 ? view : new Context2(view, void 0);
        return this.renderTokens(tokens, context, partials, template, config2);
      };
      Writer.prototype.renderTokens = function renderTokens(tokens, context, partials, originalTemplate, config2) {
        var buffer = "";
        var token, symbol, value;
        for (var i = 0, numTokens = tokens.length; i < numTokens; ++i) {
          value = void 0;
          token = tokens[i];
          symbol = token[0];
          if (symbol === "#")
            value = this.renderSection(token, context, partials, originalTemplate, config2);
          else if (symbol === "^")
            value = this.renderInverted(token, context, partials, originalTemplate, config2);
          else if (symbol === ">")
            value = this.renderPartial(token, context, partials, config2);
          else if (symbol === "&")
            value = this.unescapedValue(token, context);
          else if (symbol === "name")
            value = this.escapedValue(token, context, config2);
          else if (symbol === "text")
            value = this.rawValue(token);
          if (value !== void 0)
            buffer += value;
        }
        return buffer;
      };
      Writer.prototype.renderSection = function renderSection(token, context, partials, originalTemplate, config2) {
        var self2 = this;
        var buffer = "";
        var value = context.lookup(token[1]);
        function subRender(template) {
          return self2.render(template, context, partials, config2);
        }
        if (!value)
          return;
        if (isArray(value)) {
          for (var j = 0, valueLength = value.length; j < valueLength; ++j) {
            buffer += this.renderTokens(token[4], context.push(value[j]), partials, originalTemplate, config2);
          }
        } else if (typeof value === "object" || typeof value === "string" || typeof value === "number") {
          buffer += this.renderTokens(token[4], context.push(value), partials, originalTemplate, config2);
        } else if (isFunction(value)) {
          if (typeof originalTemplate !== "string")
            throw new Error("Cannot use higher-order sections without the original template");
          value = value.call(context.view, originalTemplate.slice(token[3], token[5]), subRender);
          if (value != null)
            buffer += value;
        } else {
          buffer += this.renderTokens(token[4], context, partials, originalTemplate, config2);
        }
        return buffer;
      };
      Writer.prototype.renderInverted = function renderInverted(token, context, partials, originalTemplate, config2) {
        var value = context.lookup(token[1]);
        if (!value || isArray(value) && value.length === 0)
          return this.renderTokens(token[4], context, partials, originalTemplate, config2);
      };
      Writer.prototype.indentPartial = function indentPartial(partial, indentation, lineHasNonSpace) {
        var filteredIndentation = indentation.replace(/[^ \t]/g, "");
        var partialByNl = partial.split("\n");
        for (var i = 0; i < partialByNl.length; i++) {
          if (partialByNl[i].length && (i > 0 || !lineHasNonSpace)) {
            partialByNl[i] = filteredIndentation + partialByNl[i];
          }
        }
        return partialByNl.join("\n");
      };
      Writer.prototype.renderPartial = function renderPartial(token, context, partials, config2) {
        if (!partials)
          return;
        var tags = this.getConfigTags(config2);
        var value = isFunction(partials) ? partials(token[1]) : partials[token[1]];
        if (value != null) {
          var lineHasNonSpace = token[6];
          var tagIndex = token[5];
          var indentation = token[4];
          var indentedValue = value;
          if (tagIndex == 0 && indentation) {
            indentedValue = this.indentPartial(value, indentation, lineHasNonSpace);
          }
          var tokens = this.parse(indentedValue, tags);
          return this.renderTokens(tokens, context, partials, indentedValue, config2);
        }
      };
      Writer.prototype.unescapedValue = function unescapedValue(token, context) {
        var value = context.lookup(token[1]);
        if (value != null)
          return value;
      };
      Writer.prototype.escapedValue = function escapedValue(token, context, config2) {
        var escape = this.getConfigEscape(config2) || mustache.escape;
        var value = context.lookup(token[1]);
        if (value != null)
          return typeof value === "number" && escape === mustache.escape ? String(value) : escape(value);
      };
      Writer.prototype.rawValue = function rawValue(token) {
        return token[1];
      };
      Writer.prototype.getConfigTags = function getConfigTags(config2) {
        if (isArray(config2)) {
          return config2;
        } else if (config2 && typeof config2 === "object") {
          return config2.tags;
        } else {
          return void 0;
        }
      };
      Writer.prototype.getConfigEscape = function getConfigEscape(config2) {
        if (config2 && typeof config2 === "object" && !isArray(config2)) {
          return config2.escape;
        } else {
          return void 0;
        }
      };
      var mustache = {
        name: "mustache.js",
        version: "4.1.0",
        tags: ["{{", "}}"],
        clearCache: void 0,
        escape: void 0,
        parse: void 0,
        render: void 0,
        Scanner: void 0,
        Context: void 0,
        Writer: void 0,
        /**
         * Allows a user to override the default caching strategy, by providing an
         * object with set, get and clear methods. This can also be used to disable
         * the cache by setting it to the literal `undefined`.
         */
        set templateCache(cache) {
          defaultWriter.templateCache = cache;
        },
        /**
         * Gets the default or overridden caching object from the default writer.
         */
        get templateCache() {
          return defaultWriter.templateCache;
        }
      };
      var defaultWriter = new Writer();
      mustache.clearCache = function clearCache() {
        return defaultWriter.clearCache();
      };
      mustache.parse = function parse3(template, tags) {
        return defaultWriter.parse(template, tags);
      };
      mustache.render = function render2(template, view, partials, config2) {
        if (typeof template !== "string") {
          throw new TypeError('Invalid template! Template should be a "string" but "' + typeStr(template) + '" was given as the first argument for mustache#render(template, view, partials)');
        }
        return defaultWriter.render(template, view, partials, config2);
      };
      mustache.escape = escapeHtml;
      mustache.Scanner = Scanner;
      mustache.Context = Context2;
      mustache.Writer = Writer;
      return mustache;
    });
  }
});

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => TGInbox
});
module.exports = __toCommonJS(main_exports);
var import_obsidian7 = require("obsidian");

// node_modules/.pnpm/grammy@1.21.1/node_modules/grammy/out/web.mjs
var filterQueryCache = /* @__PURE__ */ new Map();
function matchFilter(filter) {
  var _a;
  const queries = Array.isArray(filter) ? filter : [
    filter
  ];
  const key = queries.join(",");
  const predicate = (_a = filterQueryCache.get(key)) != null ? _a : (() => {
    const parsed = parse(queries);
    const pred = compile(parsed);
    filterQueryCache.set(key, pred);
    return pred;
  })();
  return (ctx) => predicate(ctx);
}
function parse(filter) {
  return Array.isArray(filter) ? filter.map((q) => q.split(":")) : [
    filter.split(":")
  ];
}
function compile(parsed) {
  const preprocessed = parsed.flatMap((q) => check(q, preprocess(q)));
  const ltree = treeify(preprocessed);
  const predicate = arborist(ltree);
  return (ctx) => !!predicate(ctx.update, ctx);
}
function preprocess(filter) {
  const valid = UPDATE_KEYS;
  const expanded = [
    filter
  ].flatMap((q) => {
    const [l1, l2, l3] = q;
    if (!(l1 in L1_SHORTCUTS))
      return [
        q
      ];
    if (!l1 && !l2 && !l3)
      return [
        q
      ];
    const targets = L1_SHORTCUTS[l1];
    const expanded2 = targets.map((s2) => [
      s2,
      l2,
      l3
    ]);
    if (l2 === void 0)
      return expanded2;
    if (l2 in L2_SHORTCUTS && (l2 || l3))
      return expanded2;
    return expanded2.filter(([s2]) => {
      var _a;
      return !!((_a = valid[s2]) == null ? void 0 : _a[l2]);
    });
  }).flatMap((q) => {
    const [l1, l2, l3] = q;
    if (!(l2 in L2_SHORTCUTS))
      return [
        q
      ];
    if (!l2 && !l3)
      return [
        q
      ];
    const targets = L2_SHORTCUTS[l2];
    const expanded2 = targets.map((s2) => [
      l1,
      s2,
      l3
    ]);
    if (l3 === void 0)
      return expanded2;
    return expanded2.filter(([, s2]) => {
      var _a, _b;
      return !!((_b = (_a = valid[l1]) == null ? void 0 : _a[s2]) == null ? void 0 : _b[l3]);
    });
  });
  if (expanded.length === 0) {
    throw new Error(`Shortcuts in '${filter.join(":")}' do not expand to any valid filter query`);
  }
  return expanded;
}
function check(original, preprocessed) {
  if (preprocessed.length === 0)
    throw new Error("Empty filter query given");
  const errors = preprocessed.map(checkOne).filter((r) => r !== true);
  if (errors.length === 0)
    return preprocessed;
  else if (errors.length === 1)
    throw new Error(errors[0]);
  else {
    throw new Error(`Invalid filter query '${original.join(":")}'. There are ${errors.length} errors after expanding the contained shortcuts: ${errors.join("; ")}`);
  }
}
function checkOne(filter) {
  const [l1, l2, l3, ...n] = filter;
  if (l1 === void 0)
    return "Empty filter query given";
  if (!(l1 in UPDATE_KEYS || l1 === "chat_boost" || l1 === "removed_chat_boost")) {
    const permitted = Object.keys(UPDATE_KEYS);
    return `Invalid L1 filter '${l1}' given in '${filter.join(":")}'. Permitted values are: ${permitted.map((k) => `'${k}'`).join(", ")}.`;
  }
  if (l2 === void 0)
    return true;
  const l1Obj = UPDATE_KEYS[l1];
  if (!(l2 in l1Obj)) {
    const permitted = Object.keys(l1Obj);
    return `Invalid L2 filter '${l2}' given in '${filter.join(":")}'. Permitted values are: ${permitted.map((k) => `'${k}'`).join(", ")}.`;
  }
  if (l3 === void 0)
    return true;
  const l2Obj = l1Obj[l2];
  if (!(l3 in l2Obj)) {
    const permitted = Object.keys(l2Obj);
    return `Invalid L3 filter '${l3}' given in '${filter.join(":")}'. ${permitted.length === 0 ? `No further filtering is possible after '${l1}:${l2}'.` : `Permitted values are: ${permitted.map((k) => `'${k}'`).join(", ")}.`}`;
  }
  if (n.length === 0)
    return true;
  return `Cannot filter further than three levels, ':${n.join(":")}' is invalid!`;
}
function treeify(paths) {
  var _a, _b;
  const tree = {};
  for (const [l1, l2, l3] of paths) {
    const subtree = (_a = tree[l1]) != null ? _a : tree[l1] = {};
    if (l2 !== void 0) {
      const set = (_b = subtree[l2]) != null ? _b : subtree[l2] = /* @__PURE__ */ new Set();
      if (l3 !== void 0)
        set.add(l3);
    }
  }
  return tree;
}
function or(left, right) {
  return (obj, ctx) => left(obj, ctx) || right(obj, ctx);
}
function concat(get, test) {
  return (obj, ctx) => {
    const nextObj = get(obj, ctx);
    return nextObj && test(nextObj, ctx);
  };
}
function leaf(pred) {
  return (obj, ctx) => pred(obj, ctx) != null;
}
function arborist(tree) {
  const l1Predicates = Object.entries(tree).map(([l1, subtree]) => {
    const l1Pred = (obj) => obj[l1];
    const l2Predicates = Object.entries(subtree).map(([l2, set]) => {
      const l2Pred = (obj) => obj[l2];
      const l3Predicates = Array.from(set).map((l3) => {
        const l3Pred = l3 === "me" ? (obj, ctx) => {
          const me = ctx.me.id;
          return testMaybeArray(obj, (u) => u.id === me);
        } : (obj) => testMaybeArray(obj, (e) => e[l3] || e.type === l3);
        return l3Pred;
      });
      return l3Predicates.length === 0 ? leaf(l2Pred) : concat(l2Pred, l3Predicates.reduce(or));
    });
    return l2Predicates.length === 0 ? leaf(l1Pred) : concat(l1Pred, l2Predicates.reduce(or));
  });
  if (l1Predicates.length === 0) {
    throw new Error("Cannot create filter function for empty query");
  }
  return l1Predicates.reduce(or);
}
function testMaybeArray(t, pred) {
  const p = (x) => x != null && pred(x);
  return Array.isArray(t) ? t.some(p) : p(t);
}
var ENTITY_KEYS = {
  mention: {},
  hashtag: {},
  cashtag: {},
  bot_command: {},
  url: {},
  email: {},
  phone_number: {},
  bold: {},
  italic: {},
  underline: {},
  strikethrough: {},
  spoiler: {},
  code: {},
  pre: {},
  text_link: {},
  text_mention: {},
  custom_emoji: {}
};
var USER_KEYS = {
  me: {},
  is_bot: {},
  is_premium: {},
  added_to_attachment_menu: {}
};
var FORWARD_ORIGIN_KEYS = {
  user: {},
  hidden_user: {},
  chat: {},
  channel: {}
};
var STICKER_KEYS = {
  is_video: {},
  is_animated: {},
  premium_animation: {}
};
var REACTION_KEYS = {
  emoji: {},
  custom_emoji: {}
};
var COMMON_MESSAGE_KEYS = {
  forward_origin: FORWARD_ORIGIN_KEYS,
  is_topic_message: {},
  is_automatic_forward: {},
  text: {},
  animation: {},
  audio: {},
  document: {},
  photo: {},
  sticker: STICKER_KEYS,
  story: {},
  video: {},
  video_note: {},
  voice: {},
  contact: {},
  dice: {},
  game: {},
  poll: {},
  venue: {},
  location: {},
  entities: ENTITY_KEYS,
  caption_entities: ENTITY_KEYS,
  caption: {},
  has_media_spoiler: {},
  new_chat_title: {},
  new_chat_photo: {},
  delete_chat_photo: {},
  message_auto_delete_timer_changed: {},
  pinned_message: {},
  invoice: {},
  proximity_alert_triggered: {},
  video_chat_scheduled: {},
  video_chat_started: {},
  video_chat_ended: {},
  video_chat_participants_invited: {},
  web_app_data: {}
};
var MESSAGE_KEYS = {
  ...COMMON_MESSAGE_KEYS,
  sender_boost_count: {},
  new_chat_members: USER_KEYS,
  left_chat_member: USER_KEYS,
  group_chat_created: {},
  supergroup_chat_created: {},
  migrate_to_chat_id: {},
  migrate_from_chat_id: {},
  successful_payment: {},
  boost_added: {},
  users_shared: {},
  chat_shared: {},
  connected_website: {},
  write_access_allowed: {},
  passport_data: {},
  forum_topic_created: {},
  forum_topic_edited: {
    name: {},
    icon_custom_emoji_id: {}
  },
  forum_topic_closed: {},
  forum_topic_reopened: {},
  general_forum_topic_hidden: {},
  general_forum_topic_unhidden: {}
};
var CHANNEL_POST_KEYS = {
  ...COMMON_MESSAGE_KEYS,
  channel_chat_created: {}
};
var CALLBACK_QUERY_KEYS = {
  data: {},
  game_short_name: {}
};
var CHAT_MEMBER_UPDATED_KEYS = {
  from: USER_KEYS
};
var MESSAGE_REACTION_UPDATED_KEYS = {
  old_reaction: REACTION_KEYS,
  new_reaction: REACTION_KEYS
};
var MESSAGE_REACTION_COUNT_UPDATED_KEYS = {
  reactions: REACTION_KEYS
};
var UPDATE_KEYS = {
  message: MESSAGE_KEYS,
  edited_message: MESSAGE_KEYS,
  channel_post: CHANNEL_POST_KEYS,
  edited_channel_post: CHANNEL_POST_KEYS,
  inline_query: {},
  chosen_inline_result: {},
  callback_query: CALLBACK_QUERY_KEYS,
  shipping_query: {},
  pre_checkout_query: {},
  poll: {},
  poll_answer: {},
  my_chat_member: CHAT_MEMBER_UPDATED_KEYS,
  chat_member: CHAT_MEMBER_UPDATED_KEYS,
  chat_join_request: {},
  message_reaction: MESSAGE_REACTION_UPDATED_KEYS,
  message_reaction_count: MESSAGE_REACTION_COUNT_UPDATED_KEYS
};
var L1_SHORTCUTS = {
  "": [
    "message",
    "channel_post"
  ],
  msg: [
    "message",
    "channel_post"
  ],
  edit: [
    "edited_message",
    "edited_channel_post"
  ]
};
var L2_SHORTCUTS = {
  "": [
    "entities",
    "caption_entities"
  ],
  media: [
    "photo",
    "video"
  ],
  file: [
    "photo",
    "animation",
    "audio",
    "document",
    "video",
    "video_note",
    "voice",
    "sticker"
  ]
};
var checker = {
  filterQuery(filter) {
    const pred = matchFilter(filter);
    return (ctx) => pred(ctx);
  },
  text(trigger) {
    const hasText = checker.filterQuery([
      ":text",
      ":caption"
    ]);
    const trg = triggerFn(trigger);
    return (ctx) => {
      var _a, _b;
      if (!hasText(ctx))
        return false;
      const msg = (_a = ctx.message) != null ? _a : ctx.channelPost;
      const txt = (_b = msg.text) != null ? _b : msg.caption;
      return match(ctx, txt, trg);
    };
  },
  command(command) {
    const hasEntities = checker.filterQuery(":entities:bot_command");
    const atCommands = /* @__PURE__ */ new Set();
    const noAtCommands = /* @__PURE__ */ new Set();
    toArray(command).forEach((cmd) => {
      if (cmd.startsWith("/")) {
        throw new Error(`Do not include '/' when registering command handlers (use '${cmd.substring(1)}' not '${cmd}')`);
      }
      const set = cmd.includes("@") ? atCommands : noAtCommands;
      set.add(cmd);
    });
    return (ctx) => {
      var _a, _b;
      if (!hasEntities(ctx))
        return false;
      const msg = (_a = ctx.message) != null ? _a : ctx.channelPost;
      const txt = (_b = msg.text) != null ? _b : msg.caption;
      return msg.entities.some((e) => {
        if (e.type !== "bot_command")
          return false;
        if (e.offset !== 0)
          return false;
        const cmd = txt.substring(1, e.length);
        if (noAtCommands.has(cmd) || atCommands.has(cmd)) {
          ctx.match = txt.substring(cmd.length + 1).trimStart();
          return true;
        }
        const index = cmd.indexOf("@");
        if (index === -1)
          return false;
        const atTarget = cmd.substring(index + 1).toLowerCase();
        const username = ctx.me.username.toLowerCase();
        if (atTarget !== username)
          return false;
        const atCommand = cmd.substring(0, index);
        if (noAtCommands.has(atCommand)) {
          ctx.match = txt.substring(cmd.length + 1).trimStart();
          return true;
        }
        return false;
      });
    };
  },
  reaction(reaction) {
    const hasMessageReaction = checker.filterQuery("message_reaction");
    const normalized = typeof reaction === "string" ? [
      {
        type: "emoji",
        emoji: reaction
      }
    ] : (Array.isArray(reaction) ? reaction : [
      reaction
    ]).map((emoji) => typeof emoji === "string" ? {
      type: "emoji",
      emoji
    } : emoji);
    return (ctx) => {
      if (!hasMessageReaction(ctx))
        return false;
      const { old_reaction, new_reaction } = ctx.messageReaction;
      for (const reaction2 of new_reaction) {
        let isOld = false;
        if (reaction2.type === "emoji") {
          for (const old of old_reaction) {
            if (old.type !== "emoji")
              continue;
            if (old.emoji === reaction2.emoji) {
              isOld = true;
              break;
            }
          }
        } else if (reaction2.type === "custom_emoji") {
          for (const old of old_reaction) {
            if (old.type !== "custom_emoji")
              continue;
            if (old.custom_emoji_id === reaction2.custom_emoji_id) {
              isOld = true;
              break;
            }
          }
        } else {
        }
        if (!isOld) {
          if (reaction2.type === "emoji") {
            for (const wanted of normalized) {
              if (wanted.type !== "emoji")
                continue;
              if (wanted.emoji === reaction2.emoji) {
                return true;
              }
            }
          } else if (reaction2.type === "custom_emoji") {
            for (const wanted of normalized) {
              if (wanted.type !== "custom_emoji")
                continue;
              if (wanted.custom_emoji_id === reaction2.custom_emoji_id) {
                return true;
              }
            }
          } else {
            return true;
          }
        }
      }
      return false;
    };
  },
  chatType(chatType) {
    const set = new Set(toArray(chatType));
    return (ctx) => {
      var _a;
      return ((_a = ctx.chat) == null ? void 0 : _a.type) !== void 0 && set.has(ctx.chat.type);
    };
  },
  callbackQuery(trigger) {
    const hasCallbackQuery = checker.filterQuery("callback_query:data");
    const trg = triggerFn(trigger);
    return (ctx) => hasCallbackQuery(ctx) && match(ctx, ctx.callbackQuery.data, trg);
  },
  gameQuery(trigger) {
    const hasGameQuery = checker.filterQuery("callback_query:game_short_name");
    const trg = triggerFn(trigger);
    return (ctx) => hasGameQuery(ctx) && match(ctx, ctx.callbackQuery.game_short_name, trg);
  },
  inlineQuery(trigger) {
    const hasInlineQuery = checker.filterQuery("inline_query");
    const trg = triggerFn(trigger);
    return (ctx) => hasInlineQuery(ctx) && match(ctx, ctx.inlineQuery.query, trg);
  },
  chosenInlineResult(trigger) {
    const hasChosenInlineResult = checker.filterQuery("chosen_inline_result");
    const trg = triggerFn(trigger);
    return (ctx) => hasChosenInlineResult(ctx) && match(ctx, ctx.chosenInlineResult.result_id, trg);
  }
};
var _Context = class {
  constructor(update, api, me) {
    __publicField(this, "update");
    __publicField(this, "api");
    __publicField(this, "me");
    __publicField(this, "match");
    this.update = update;
    this.api = api;
    this.me = me;
  }
  get message() {
    return this.update.message;
  }
  get editedMessage() {
    return this.update.edited_message;
  }
  get channelPost() {
    return this.update.channel_post;
  }
  get editedChannelPost() {
    return this.update.edited_channel_post;
  }
  get messageReaction() {
    return this.update.message_reaction;
  }
  get messageReactionCount() {
    return this.update.message_reaction_count;
  }
  get inlineQuery() {
    return this.update.inline_query;
  }
  get chosenInlineResult() {
    return this.update.chosen_inline_result;
  }
  get callbackQuery() {
    return this.update.callback_query;
  }
  get shippingQuery() {
    return this.update.shipping_query;
  }
  get preCheckoutQuery() {
    return this.update.pre_checkout_query;
  }
  get poll() {
    return this.update.poll;
  }
  get pollAnswer() {
    return this.update.poll_answer;
  }
  get myChatMember() {
    return this.update.my_chat_member;
  }
  get chatMember() {
    return this.update.chat_member;
  }
  get chatJoinRequest() {
    return this.update.chat_join_request;
  }
  get chatBoost() {
    return this.update.chat_boost;
  }
  get removedChatBoost() {
    return this.update.removed_chat_boost;
  }
  get msg() {
    var _a, _b, _c, _d, _e;
    return (_e = (_d = (_c = (_a = this.message) != null ? _a : this.editedMessage) != null ? _c : (_b = this.callbackQuery) == null ? void 0 : _b.message) != null ? _d : this.channelPost) != null ? _e : this.editedChannelPost;
  }
  get chat() {
    var _a, _b, _c, _d, _e, _f, _g, _h;
    return (_h = (_g = (_f = (_e = (_d = (_c = (_b = (_a = this.msg) != null ? _a : this.messageReaction) != null ? _b : this.messageReactionCount) != null ? _c : this.myChatMember) != null ? _d : this.chatMember) != null ? _e : this.chatJoinRequest) != null ? _f : this.chatBoost) != null ? _g : this.removedChatBoost) == null ? void 0 : _h.chat;
  }
  get senderChat() {
    var _a;
    return (_a = this.msg) == null ? void 0 : _a.sender_chat;
  }
  get from() {
    var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k;
    return (_k = (_a = this.messageReaction) == null ? void 0 : _a.user) != null ? _k : (_j = (_i = (_h = (_g = (_f = (_e = (_d = (_c = (_b = this.callbackQuery) != null ? _b : this.inlineQuery) != null ? _c : this.shippingQuery) != null ? _d : this.preCheckoutQuery) != null ? _e : this.chosenInlineResult) != null ? _f : this.msg) != null ? _g : this.myChatMember) != null ? _h : this.chatMember) != null ? _i : this.chatJoinRequest) == null ? void 0 : _j.from;
  }
  get inlineMessageId() {
    var _a, _b, _c;
    return (_c = (_a = this.callbackQuery) == null ? void 0 : _a.inline_message_id) != null ? _c : (_b = this.chosenInlineResult) == null ? void 0 : _b.inline_message_id;
  }
  entities(types) {
    var _a, _b;
    const message = this.msg;
    if (message === void 0)
      return [];
    const text = (_a = message.text) != null ? _a : message.caption;
    if (text === void 0)
      return [];
    let entities = (_b = message.entities) != null ? _b : message.caption_entities;
    if (entities === void 0)
      return [];
    if (types !== void 0) {
      const filters = new Set(toArray(types));
      entities = entities.filter((entity) => filters.has(entity.type));
    }
    return entities.map((entity) => ({
      ...entity,
      text: text.substring(entity.offset, entity.offset + entity.length)
    }));
  }
  reactions() {
    const emoji = [];
    const emojiAdded = [];
    const emojiKept = [];
    const emojiRemoved = [];
    const customEmoji = [];
    const customEmojiAdded = [];
    const customEmojiKept = [];
    const customEmojiRemoved = [];
    const r = this.messageReaction;
    if (r !== void 0) {
      const { old_reaction, new_reaction } = r;
      for (const reaction of new_reaction) {
        if (reaction.type === "emoji") {
          emoji.push(reaction.emoji);
        } else if (reaction.type === "custom_emoji") {
          customEmoji.push(reaction.custom_emoji_id);
        }
      }
      for (const reaction of old_reaction) {
        if (reaction.type === "emoji") {
          emojiRemoved.push(reaction.emoji);
        } else if (reaction.type === "custom_emoji") {
          customEmojiRemoved.push(reaction.custom_emoji_id);
        }
      }
      emojiAdded.push(...emoji);
      customEmojiAdded.push(...customEmoji);
      for (let i = 0; i < emojiRemoved.length; i++) {
        const len = emojiAdded.length;
        if (len === 0)
          break;
        const rem = emojiRemoved[i];
        for (let j = 0; j < len; j++) {
          if (rem === emojiAdded[j]) {
            emojiKept.push(rem);
            emojiRemoved.splice(i, 1);
            emojiAdded.splice(j, 1);
            i--;
            break;
          }
        }
      }
      for (let i = 0; i < customEmojiRemoved.length; i++) {
        const len = customEmojiAdded.length;
        if (len === 0)
          break;
        const rem = customEmojiRemoved[i];
        for (let j = 0; j < len; j++) {
          if (rem === customEmojiAdded[j]) {
            customEmojiKept.push(rem);
            customEmojiRemoved.splice(i, 1);
            customEmojiAdded.splice(j, 1);
            i--;
            break;
          }
        }
      }
    }
    return {
      emoji,
      emojiAdded,
      emojiKept,
      emojiRemoved,
      customEmoji,
      customEmojiAdded,
      customEmojiKept,
      customEmojiRemoved
    };
  }
  has(filter) {
    return _Context.has.filterQuery(filter)(this);
  }
  hasText(trigger) {
    return _Context.has.text(trigger)(this);
  }
  hasCommand(command) {
    return _Context.has.command(command)(this);
  }
  hasReaction(reaction) {
    return _Context.has.reaction(reaction)(this);
  }
  hasChatType(chatType) {
    return _Context.has.chatType(chatType)(this);
  }
  hasCallbackQuery(trigger) {
    return _Context.has.callbackQuery(trigger)(this);
  }
  hasGameQuery(trigger) {
    return _Context.has.gameQuery(trigger)(this);
  }
  hasInlineQuery(trigger) {
    return _Context.has.inlineQuery(trigger)(this);
  }
  hasChosenInlineResult(trigger) {
    return _Context.has.chosenInlineResult(trigger)(this);
  }
  reply(text, other, signal) {
    return this.api.sendMessage(orThrow(this.chat, "sendMessage").id, text, other, signal);
  }
  forwardMessage(chat_id, other, signal) {
    var _a, _b, _c, _d, _e;
    return this.api.forwardMessage(chat_id, orThrow(this.chat, "forwardMessage").id, orThrow((_e = (_c = (_a = this.msg) == null ? void 0 : _a.message_id) != null ? _c : (_b = this.messageReaction) == null ? void 0 : _b.message_id) != null ? _e : (_d = this.messageReactionCount) == null ? void 0 : _d.message_id, "forwardMessage"), other, signal);
  }
  forwardMessages(chat_id, message_ids, other, signal) {
    return this.api.forwardMessages(chat_id, orThrow(this.chat, "forwardMessages").id, message_ids, other, signal);
  }
  copyMessage(chat_id, other, signal) {
    var _a, _b, _c, _d, _e;
    return this.api.copyMessage(chat_id, orThrow(this.chat, "copyMessage").id, orThrow((_e = (_c = (_a = this.msg) == null ? void 0 : _a.message_id) != null ? _c : (_b = this.messageReaction) == null ? void 0 : _b.message_id) != null ? _e : (_d = this.messageReactionCount) == null ? void 0 : _d.message_id, "copyMessage"), other, signal);
  }
  copyMessages(chat_id, message_ids, other, signal) {
    return this.api.copyMessages(chat_id, orThrow(this.chat, "copyMessages").id, message_ids, other, signal);
  }
  replyWithPhoto(photo, other, signal) {
    return this.api.sendPhoto(orThrow(this.chat, "sendPhoto").id, photo, other, signal);
  }
  replyWithAudio(audio, other, signal) {
    return this.api.sendAudio(orThrow(this.chat, "sendAudio").id, audio, other, signal);
  }
  replyWithDocument(document1, other, signal) {
    return this.api.sendDocument(orThrow(this.chat, "sendDocument").id, document1, other, signal);
  }
  replyWithVideo(video, other, signal) {
    return this.api.sendVideo(orThrow(this.chat, "sendVideo").id, video, other, signal);
  }
  replyWithAnimation(animation, other, signal) {
    return this.api.sendAnimation(orThrow(this.chat, "sendAnimation").id, animation, other, signal);
  }
  replyWithVoice(voice, other, signal) {
    return this.api.sendVoice(orThrow(this.chat, "sendVoice").id, voice, other, signal);
  }
  replyWithVideoNote(video_note, other, signal) {
    return this.api.sendVideoNote(orThrow(this.chat, "sendVideoNote").id, video_note, other, signal);
  }
  replyWithMediaGroup(media, other, signal) {
    return this.api.sendMediaGroup(orThrow(this.chat, "sendMediaGroup").id, media, other, signal);
  }
  replyWithLocation(latitude, longitude, other, signal) {
    return this.api.sendLocation(orThrow(this.chat, "sendLocation").id, latitude, longitude, other, signal);
  }
  editMessageLiveLocation(latitude, longitude, other, signal) {
    var _a, _b, _c, _d, _e;
    const inlineId = this.inlineMessageId;
    return inlineId !== void 0 ? this.api.editMessageLiveLocationInline(inlineId, latitude, longitude, other) : this.api.editMessageLiveLocation(orThrow(this.chat, "editMessageLiveLocation").id, orThrow((_e = (_c = (_a = this.msg) == null ? void 0 : _a.message_id) != null ? _c : (_b = this.messageReaction) == null ? void 0 : _b.message_id) != null ? _e : (_d = this.messageReactionCount) == null ? void 0 : _d.message_id, "editMessageLiveLocation"), latitude, longitude, other, signal);
  }
  stopMessageLiveLocation(other, signal) {
    var _a, _b, _c, _d, _e;
    const inlineId = this.inlineMessageId;
    return inlineId !== void 0 ? this.api.stopMessageLiveLocationInline(inlineId, other) : this.api.stopMessageLiveLocation(orThrow(this.chat, "stopMessageLiveLocation").id, orThrow((_e = (_c = (_a = this.msg) == null ? void 0 : _a.message_id) != null ? _c : (_b = this.messageReaction) == null ? void 0 : _b.message_id) != null ? _e : (_d = this.messageReactionCount) == null ? void 0 : _d.message_id, "stopMessageLiveLocation"), other, signal);
  }
  replyWithVenue(latitude, longitude, title2, address, other, signal) {
    return this.api.sendVenue(orThrow(this.chat, "sendVenue").id, latitude, longitude, title2, address, other, signal);
  }
  replyWithContact(phone_number, first_name, other, signal) {
    return this.api.sendContact(orThrow(this.chat, "sendContact").id, phone_number, first_name, other, signal);
  }
  replyWithPoll(question, options, other, signal) {
    return this.api.sendPoll(orThrow(this.chat, "sendPoll").id, question, options, other, signal);
  }
  replyWithDice(emoji, other, signal) {
    return this.api.sendDice(orThrow(this.chat, "sendDice").id, emoji, other, signal);
  }
  react(reaction, other, signal) {
    var _a, _b, _c, _d, _e;
    return this.api.setMessageReaction(orThrow(this.chat, "setMessageReaction").id, orThrow((_e = (_c = (_a = this.msg) == null ? void 0 : _a.message_id) != null ? _c : (_b = this.messageReaction) == null ? void 0 : _b.message_id) != null ? _e : (_d = this.messageReactionCount) == null ? void 0 : _d.message_id, "setMessageReaction"), typeof reaction === "string" ? [
      {
        type: "emoji",
        emoji: reaction
      }
    ] : (Array.isArray(reaction) ? reaction : [
      reaction
    ]).map((emoji) => typeof emoji === "string" ? {
      type: "emoji",
      emoji
    } : emoji), other, signal);
  }
  replyWithChatAction(action, other, signal) {
    return this.api.sendChatAction(orThrow(this.chat, "sendChatAction").id, action, other, signal);
  }
  getUserProfilePhotos(other, signal) {
    return this.api.getUserProfilePhotos(orThrow(this.from, "getUserProfilePhotos").id, other, signal);
  }
  getUserChatBoosts(chat_id, signal) {
    return this.api.getUserChatBoosts(chat_id, orThrow(this.from, "getUserChatBoosts").id, signal);
  }
  getFile(signal) {
    var _a, _b, _c, _d, _e, _f;
    const m2 = orThrow(this.msg, "getFile");
    const file = m2.photo !== void 0 ? m2.photo[m2.photo.length - 1] : (_f = (_e = (_d = (_c = (_b = (_a = m2.animation) != null ? _a : m2.audio) != null ? _b : m2.document) != null ? _c : m2.video) != null ? _d : m2.video_note) != null ? _e : m2.voice) != null ? _f : m2.sticker;
    return this.api.getFile(orThrow(file, "getFile").file_id, signal);
  }
  kickAuthor(...args) {
    return this.banAuthor(...args);
  }
  banAuthor(other, signal) {
    return this.api.banChatMember(orThrow(this.chat, "banAuthor").id, orThrow(this.from, "banAuthor").id, other, signal);
  }
  kickChatMember(...args) {
    return this.banChatMember(...args);
  }
  banChatMember(user_id, other, signal) {
    return this.api.banChatMember(orThrow(this.chat, "banChatMember").id, user_id, other, signal);
  }
  unbanChatMember(user_id, other, signal) {
    return this.api.unbanChatMember(orThrow(this.chat, "unbanChatMember").id, user_id, other, signal);
  }
  restrictAuthor(permissions, other, signal) {
    return this.api.restrictChatMember(orThrow(this.chat, "restrictAuthor").id, orThrow(this.from, "restrictAuthor").id, permissions, other, signal);
  }
  restrictChatMember(user_id, permissions, other, signal) {
    return this.api.restrictChatMember(orThrow(this.chat, "restrictChatMember").id, user_id, permissions, other, signal);
  }
  promoteAuthor(other, signal) {
    return this.api.promoteChatMember(orThrow(this.chat, "promoteAuthor").id, orThrow(this.from, "promoteAuthor").id, other, signal);
  }
  promoteChatMember(user_id, other, signal) {
    return this.api.promoteChatMember(orThrow(this.chat, "promoteChatMember").id, user_id, other, signal);
  }
  setChatAdministratorAuthorCustomTitle(custom_title, signal) {
    return this.api.setChatAdministratorCustomTitle(orThrow(this.chat, "setChatAdministratorAuthorCustomTitle").id, orThrow(this.from, "setChatAdministratorAuthorCustomTitle").id, custom_title, signal);
  }
  setChatAdministratorCustomTitle(user_id, custom_title, signal) {
    return this.api.setChatAdministratorCustomTitle(orThrow(this.chat, "setChatAdministratorCustomTitle").id, user_id, custom_title, signal);
  }
  banChatSenderChat(sender_chat_id, signal) {
    return this.api.banChatSenderChat(orThrow(this.chat, "banChatSenderChat").id, sender_chat_id, signal);
  }
  unbanChatSenderChat(sender_chat_id, signal) {
    return this.api.unbanChatSenderChat(orThrow(this.chat, "unbanChatSenderChat").id, sender_chat_id, signal);
  }
  setChatPermissions(permissions, signal) {
    return this.api.setChatPermissions(orThrow(this.chat, "setChatPermissions").id, permissions, signal);
  }
  exportChatInviteLink(signal) {
    return this.api.exportChatInviteLink(orThrow(this.chat, "exportChatInviteLink").id, signal);
  }
  createChatInviteLink(other, signal) {
    return this.api.createChatInviteLink(orThrow(this.chat, "createChatInviteLink").id, other, signal);
  }
  editChatInviteLink(invite_link, other, signal) {
    return this.api.editChatInviteLink(orThrow(this.chat, "editChatInviteLink").id, invite_link, other, signal);
  }
  revokeChatInviteLink(invite_link, signal) {
    return this.api.revokeChatInviteLink(orThrow(this.chat, "editChatInviteLink").id, invite_link, signal);
  }
  approveChatJoinRequest(user_id, signal) {
    return this.api.approveChatJoinRequest(orThrow(this.chat, "approveChatJoinRequest").id, user_id, signal);
  }
  declineChatJoinRequest(user_id, signal) {
    return this.api.declineChatJoinRequest(orThrow(this.chat, "declineChatJoinRequest").id, user_id, signal);
  }
  setChatPhoto(photo, signal) {
    return this.api.setChatPhoto(orThrow(this.chat, "setChatPhoto").id, photo, signal);
  }
  deleteChatPhoto(signal) {
    return this.api.deleteChatPhoto(orThrow(this.chat, "deleteChatPhoto").id, signal);
  }
  setChatTitle(title2, signal) {
    return this.api.setChatTitle(orThrow(this.chat, "setChatTitle").id, title2, signal);
  }
  setChatDescription(description, signal) {
    return this.api.setChatDescription(orThrow(this.chat, "setChatDescription").id, description, signal);
  }
  pinChatMessage(message_id, other, signal) {
    return this.api.pinChatMessage(orThrow(this.chat, "pinChatMessage").id, message_id, other, signal);
  }
  unpinChatMessage(message_id, signal) {
    return this.api.unpinChatMessage(orThrow(this.chat, "unpinChatMessage").id, message_id, signal);
  }
  unpinAllChatMessages(signal) {
    return this.api.unpinAllChatMessages(orThrow(this.chat, "unpinAllChatMessages").id, signal);
  }
  leaveChat(signal) {
    return this.api.leaveChat(orThrow(this.chat, "leaveChat").id, signal);
  }
  getChat(signal) {
    return this.api.getChat(orThrow(this.chat, "getChat").id, signal);
  }
  getChatAdministrators(signal) {
    return this.api.getChatAdministrators(orThrow(this.chat, "getChatAdministrators").id, signal);
  }
  getChatMembersCount(...args) {
    return this.getChatMemberCount(...args);
  }
  getChatMemberCount(signal) {
    return this.api.getChatMemberCount(orThrow(this.chat, "getChatMemberCount").id, signal);
  }
  getAuthor(signal) {
    return this.api.getChatMember(orThrow(this.chat, "getAuthor").id, orThrow(this.from, "getAuthor").id, signal);
  }
  getChatMember(user_id, signal) {
    return this.api.getChatMember(orThrow(this.chat, "getChatMember").id, user_id, signal);
  }
  setChatStickerSet(sticker_set_name, signal) {
    return this.api.setChatStickerSet(orThrow(this.chat, "setChatStickerSet").id, sticker_set_name, signal);
  }
  deleteChatStickerSet(signal) {
    return this.api.deleteChatStickerSet(orThrow(this.chat, "deleteChatStickerSet").id, signal);
  }
  createForumTopic(name, other, signal) {
    return this.api.createForumTopic(orThrow(this.chat, "createForumTopic").id, name, other, signal);
  }
  editForumTopic(other, signal) {
    const message = orThrow(this.msg, "editForumTopic");
    const thread = orThrow(message.message_thread_id, "editForumTopic");
    return this.api.editForumTopic(message.chat.id, thread, other, signal);
  }
  closeForumTopic(signal) {
    const message = orThrow(this.msg, "closeForumTopic");
    const thread = orThrow(message.message_thread_id, "closeForumTopic");
    return this.api.closeForumTopic(message.chat.id, thread, signal);
  }
  reopenForumTopic(signal) {
    const message = orThrow(this.msg, "reopenForumTopic");
    const thread = orThrow(message.message_thread_id, "reopenForumTopic");
    return this.api.reopenForumTopic(message.chat.id, thread, signal);
  }
  deleteForumTopic(signal) {
    const message = orThrow(this.msg, "deleteForumTopic");
    const thread = orThrow(message.message_thread_id, "deleteForumTopic");
    return this.api.deleteForumTopic(message.chat.id, thread, signal);
  }
  unpinAllForumTopicMessages(signal) {
    const message = orThrow(this.msg, "unpinAllForumTopicMessages");
    const thread = orThrow(message.message_thread_id, "unpinAllForumTopicMessages");
    return this.api.unpinAllForumTopicMessages(message.chat.id, thread, signal);
  }
  editGeneralForumTopic(name, signal) {
    return this.api.editGeneralForumTopic(orThrow(this.chat, "editGeneralForumTopic").id, name, signal);
  }
  closeGeneralForumTopic(signal) {
    return this.api.closeGeneralForumTopic(orThrow(this.chat, "closeGeneralForumTopic").id, signal);
  }
  reopenGeneralForumTopic(signal) {
    return this.api.reopenGeneralForumTopic(orThrow(this.chat, "reopenGeneralForumTopic").id, signal);
  }
  hideGeneralForumTopic(signal) {
    return this.api.hideGeneralForumTopic(orThrow(this.chat, "hideGeneralForumTopic").id, signal);
  }
  unhideGeneralForumTopic(signal) {
    return this.api.unhideGeneralForumTopic(orThrow(this.chat, "unhideGeneralForumTopic").id, signal);
  }
  unpinAllGeneralForumTopicMessages(signal) {
    return this.api.unpinAllGeneralForumTopicMessages(orThrow(this.chat, "unpinAllGeneralForumTopicMessages").id, signal);
  }
  answerCallbackQuery(other, signal) {
    return this.api.answerCallbackQuery(orThrow(this.callbackQuery, "answerCallbackQuery").id, typeof other === "string" ? {
      text: other
    } : other, signal);
  }
  setChatMenuButton(other, signal) {
    return this.api.setChatMenuButton(other, signal);
  }
  getChatMenuButton(other, signal) {
    return this.api.getChatMenuButton(other, signal);
  }
  setMyDefaultAdministratorRights(other, signal) {
    return this.api.setMyDefaultAdministratorRights(other, signal);
  }
  getMyDefaultAdministratorRights(other, signal) {
    return this.api.getMyDefaultAdministratorRights(other, signal);
  }
  editMessageText(text, other, signal) {
    var _a, _b, _c, _d, _e;
    const inlineId = this.inlineMessageId;
    return inlineId !== void 0 ? this.api.editMessageTextInline(inlineId, text, other) : this.api.editMessageText(orThrow(this.chat, "editMessageText").id, orThrow((_e = (_c = (_a = this.msg) == null ? void 0 : _a.message_id) != null ? _c : (_b = this.messageReaction) == null ? void 0 : _b.message_id) != null ? _e : (_d = this.messageReactionCount) == null ? void 0 : _d.message_id, "editMessageText"), text, other, signal);
  }
  editMessageCaption(other, signal) {
    var _a, _b, _c, _d, _e;
    const inlineId = this.inlineMessageId;
    return inlineId !== void 0 ? this.api.editMessageCaptionInline(inlineId, other) : this.api.editMessageCaption(orThrow(this.chat, "editMessageCaption").id, orThrow((_e = (_c = (_a = this.msg) == null ? void 0 : _a.message_id) != null ? _c : (_b = this.messageReaction) == null ? void 0 : _b.message_id) != null ? _e : (_d = this.messageReactionCount) == null ? void 0 : _d.message_id, "editMessageCaption"), other, signal);
  }
  editMessageMedia(media, other, signal) {
    var _a, _b, _c, _d, _e;
    const inlineId = this.inlineMessageId;
    return inlineId !== void 0 ? this.api.editMessageMediaInline(inlineId, media, other) : this.api.editMessageMedia(orThrow(this.chat, "editMessageMedia").id, orThrow((_e = (_c = (_a = this.msg) == null ? void 0 : _a.message_id) != null ? _c : (_b = this.messageReaction) == null ? void 0 : _b.message_id) != null ? _e : (_d = this.messageReactionCount) == null ? void 0 : _d.message_id, "editMessageMedia"), media, other, signal);
  }
  editMessageReplyMarkup(other, signal) {
    var _a, _b, _c, _d, _e;
    const inlineId = this.inlineMessageId;
    return inlineId !== void 0 ? this.api.editMessageReplyMarkupInline(inlineId, other) : this.api.editMessageReplyMarkup(orThrow(this.chat, "editMessageReplyMarkup").id, orThrow((_e = (_c = (_a = this.msg) == null ? void 0 : _a.message_id) != null ? _c : (_b = this.messageReaction) == null ? void 0 : _b.message_id) != null ? _e : (_d = this.messageReactionCount) == null ? void 0 : _d.message_id, "editMessageReplyMarkup"), other, signal);
  }
  stopPoll(other, signal) {
    var _a, _b, _c, _d, _e;
    return this.api.stopPoll(orThrow(this.chat, "stopPoll").id, orThrow((_e = (_c = (_a = this.msg) == null ? void 0 : _a.message_id) != null ? _c : (_b = this.messageReaction) == null ? void 0 : _b.message_id) != null ? _e : (_d = this.messageReactionCount) == null ? void 0 : _d.message_id, "stopPoll"), other, signal);
  }
  deleteMessage(signal) {
    var _a, _b, _c, _d, _e;
    return this.api.deleteMessage(orThrow(this.chat, "deleteMessage").id, orThrow((_e = (_c = (_a = this.msg) == null ? void 0 : _a.message_id) != null ? _c : (_b = this.messageReaction) == null ? void 0 : _b.message_id) != null ? _e : (_d = this.messageReactionCount) == null ? void 0 : _d.message_id, "deleteMessage"), signal);
  }
  deleteMessages(message_ids, signal) {
    return this.api.deleteMessages(orThrow(this.chat, "deleteMessages").id, message_ids, signal);
  }
  replyWithSticker(sticker, other, signal) {
    return this.api.sendSticker(orThrow(this.chat, "sendSticker").id, sticker, other, signal);
  }
  getCustomEmojiStickers(signal) {
    var _a, _b;
    return this.api.getCustomEmojiStickers(((_b = (_a = this.msg) == null ? void 0 : _a.entities) != null ? _b : []).filter((e) => e.type === "custom_emoji").map((e) => e.custom_emoji_id), signal);
  }
  answerInlineQuery(results, other, signal) {
    return this.api.answerInlineQuery(orThrow(this.inlineQuery, "answerInlineQuery").id, results, other, signal);
  }
  replyWithInvoice(title2, description, payload, provider_token, currency, prices, other, signal) {
    return this.api.sendInvoice(orThrow(this.chat, "sendInvoice").id, title2, description, payload, provider_token, currency, prices, other, signal);
  }
  answerShippingQuery(ok2, other, signal) {
    return this.api.answerShippingQuery(orThrow(this.shippingQuery, "answerShippingQuery").id, ok2, other, signal);
  }
  answerPreCheckoutQuery(ok2, other, signal) {
    return this.api.answerPreCheckoutQuery(orThrow(this.preCheckoutQuery, "answerPreCheckoutQuery").id, ok2, typeof other === "string" ? {
      error_message: other
    } : other, signal);
  }
  setPassportDataErrors(errors, signal) {
    return this.api.setPassportDataErrors(orThrow(this.from, "setPassportDataErrors").id, errors, signal);
  }
  replyWithGame(game_short_name, other, signal) {
    return this.api.sendGame(orThrow(this.chat, "sendGame").id, game_short_name, other, signal);
  }
};
var Context = _Context;
__publicField(Context, "has", checker);
function orThrow(value, method) {
  if (value === void 0) {
    throw new Error(`Missing information for API call to ${method}`);
  }
  return value;
}
function triggerFn(trigger) {
  return toArray(trigger).map((t) => typeof t === "string" ? (txt) => txt === t ? t : null : (txt) => txt.match(t));
}
function match(ctx, content, triggers) {
  for (const t of triggers) {
    const res = t(content);
    if (res) {
      ctx.match = res;
      return true;
    }
  }
  return false;
}
function toArray(e) {
  return Array.isArray(e) ? e : [
    e
  ];
}
var BotError = class extends Error {
  constructor(error, ctx) {
    super(generateBotErrorMessage(error));
    __publicField(this, "error");
    __publicField(this, "ctx");
    this.error = error;
    this.ctx = ctx;
    this.name = "BotError";
    if (error instanceof Error)
      this.stack = error.stack;
  }
};
function generateBotErrorMessage(error) {
  let msg;
  if (error instanceof Error) {
    msg = `${error.name} in middleware: ${error.message}`;
  } else {
    const type = typeof error;
    msg = `Non-error value of type ${type} thrown in middleware`;
    switch (type) {
      case "bigint":
      case "boolean":
      case "number":
      case "symbol":
        msg += `: ${error}`;
        break;
      case "string":
        msg += `: ${String(error).substring(0, 50)}`;
        break;
      default:
        msg += "!";
        break;
    }
  }
  return msg;
}
function flatten(mw) {
  return typeof mw === "function" ? mw : (ctx, next) => mw.middleware()(ctx, next);
}
function concat1(first, andThen) {
  return async (ctx, next) => {
    let nextCalled = false;
    await first(ctx, async () => {
      if (nextCalled)
        throw new Error("`next` already called before!");
      else
        nextCalled = true;
      await andThen(ctx, next);
    });
  };
}
function pass(_ctx, next) {
  return next();
}
var leaf1 = () => Promise.resolve();
async function run(middleware, ctx) {
  await middleware(ctx, leaf1);
}
var Composer = class {
  constructor(...middleware) {
    __publicField(this, "handler");
    this.handler = middleware.length === 0 ? pass : middleware.map(flatten).reduce(concat1);
  }
  middleware() {
    return this.handler;
  }
  use(...middleware) {
    const composer = new Composer(...middleware);
    this.handler = concat1(this.handler, flatten(composer));
    return composer;
  }
  on(filter, ...middleware) {
    return this.filter(Context.has.filterQuery(filter), ...middleware);
  }
  hears(trigger, ...middleware) {
    return this.filter(Context.has.text(trigger), ...middleware);
  }
  command(command, ...middleware) {
    return this.filter(Context.has.command(command), ...middleware);
  }
  reaction(reaction, ...middleware) {
    return this.filter(Context.has.reaction(reaction), ...middleware);
  }
  chatType(chatType, ...middleware) {
    return this.filter(Context.has.chatType(chatType), ...middleware);
  }
  callbackQuery(trigger, ...middleware) {
    return this.filter(Context.has.callbackQuery(trigger), ...middleware);
  }
  gameQuery(trigger, ...middleware) {
    return this.filter(Context.has.gameQuery(trigger), ...middleware);
  }
  inlineQuery(trigger, ...middleware) {
    return this.filter(Context.has.inlineQuery(trigger), ...middleware);
  }
  chosenInlineResult(resultId, ...middleware) {
    return this.filter(Context.has.chosenInlineResult(resultId), ...middleware);
  }
  filter(predicate, ...middleware) {
    const composer = new Composer(...middleware);
    this.branch(predicate, composer, pass);
    return composer;
  }
  drop(predicate, ...middleware) {
    return this.filter(async (ctx) => !await predicate(ctx), ...middleware);
  }
  fork(...middleware) {
    const composer = new Composer(...middleware);
    const fork = flatten(composer);
    this.use((ctx, next) => Promise.all([
      next(),
      run(fork, ctx)
    ]));
    return composer;
  }
  lazy(middlewareFactory) {
    return this.use(async (ctx, next) => {
      const middleware = await middlewareFactory(ctx);
      const arr = Array.isArray(middleware) ? middleware : [
        middleware
      ];
      await flatten(new Composer(...arr))(ctx, next);
    });
  }
  route(router, routeHandlers, fallback = pass) {
    return this.lazy(async (ctx) => {
      var _a;
      const route = await router(ctx);
      return (_a = route === void 0 || !routeHandlers[route] ? fallback : routeHandlers[route]) != null ? _a : [];
    });
  }
  branch(predicate, trueMiddleware, falseMiddleware) {
    return this.lazy(async (ctx) => await predicate(ctx) ? trueMiddleware : falseMiddleware);
  }
  errorBoundary(errorHandler, ...middleware) {
    const composer = new Composer(...middleware);
    const bound = flatten(composer);
    this.use(async (ctx, next) => {
      let nextCalled = false;
      const cont = () => (nextCalled = true, Promise.resolve());
      try {
        await bound(ctx, cont);
      } catch (err) {
        nextCalled = false;
        await errorHandler(new BotError(err, ctx), cont);
      }
      if (nextCalled)
        await next();
    });
    return composer;
  }
};
var s = 1e3;
var m = s * 60;
var h = m * 60;
var d = h * 24;
var w = d * 7;
var y = d * 365.25;
var ms = function(val, options) {
  options = options || {};
  var type = typeof val;
  if (type === "string" && val.length > 0) {
    return parse1(val);
  } else if (type === "number" && isFinite(val)) {
    return options.long ? fmtLong(val) : fmtShort(val);
  }
  throw new Error("val is not a non-empty string or a valid number. val=" + JSON.stringify(val));
};
function parse1(str2) {
  str2 = String(str2);
  if (str2.length > 100) {
    return;
  }
  var match2 = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(str2);
  if (!match2) {
    return;
  }
  var n = parseFloat(match2[1]);
  var type = (match2[2] || "ms").toLowerCase();
  switch (type) {
    case "years":
    case "year":
    case "yrs":
    case "yr":
    case "y":
      return n * y;
    case "weeks":
    case "week":
    case "w":
      return n * w;
    case "days":
    case "day":
    case "d":
      return n * d;
    case "hours":
    case "hour":
    case "hrs":
    case "hr":
    case "h":
      return n * h;
    case "minutes":
    case "minute":
    case "mins":
    case "min":
    case "m":
      return n * m;
    case "seconds":
    case "second":
    case "secs":
    case "sec":
    case "s":
      return n * s;
    case "milliseconds":
    case "millisecond":
    case "msecs":
    case "msec":
    case "ms":
      return n;
    default:
      return void 0;
  }
}
function fmtShort(ms2) {
  var msAbs = Math.abs(ms2);
  if (msAbs >= d) {
    return Math.round(ms2 / d) + "d";
  }
  if (msAbs >= h) {
    return Math.round(ms2 / h) + "h";
  }
  if (msAbs >= m) {
    return Math.round(ms2 / m) + "m";
  }
  if (msAbs >= s) {
    return Math.round(ms2 / s) + "s";
  }
  return ms2 + "ms";
}
function fmtLong(ms2) {
  var msAbs = Math.abs(ms2);
  if (msAbs >= d) {
    return plural(ms2, msAbs, d, "day");
  }
  if (msAbs >= h) {
    return plural(ms2, msAbs, h, "hour");
  }
  if (msAbs >= m) {
    return plural(ms2, msAbs, m, "minute");
  }
  if (msAbs >= s) {
    return plural(ms2, msAbs, s, "second");
  }
  return ms2 + " ms";
}
function plural(ms2, msAbs, n, name) {
  var isPlural = msAbs >= n * 1.5;
  return Math.round(ms2 / n) + " " + name + (isPlural ? "s" : "");
}
function defaultSetTimout() {
  throw new Error("setTimeout has not been defined");
}
function defaultClearTimeout() {
  throw new Error("clearTimeout has not been defined");
}
var cachedSetTimeout = defaultSetTimout;
var cachedClearTimeout = defaultClearTimeout;
var globalContext;
if (typeof window !== "undefined") {
  globalContext = window;
} else if (typeof self !== "undefined") {
  globalContext = self;
} else {
  globalContext = {};
}
if (typeof globalContext.setTimeout === "function") {
  cachedSetTimeout = setTimeout;
}
if (typeof globalContext.clearTimeout === "function") {
  cachedClearTimeout = clearTimeout;
}
function runTimeout(fun) {
  if (cachedSetTimeout === setTimeout) {
    return setTimeout(fun, 0);
  }
  if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
    cachedSetTimeout = setTimeout;
    return setTimeout(fun, 0);
  }
  try {
    return cachedSetTimeout(fun, 0);
  } catch (e) {
    try {
      return cachedSetTimeout.call(null, fun, 0);
    } catch (e2) {
      return cachedSetTimeout.call(this, fun, 0);
    }
  }
}
function runClearTimeout(marker) {
  if (cachedClearTimeout === clearTimeout) {
    return clearTimeout(marker);
  }
  if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
    cachedClearTimeout = clearTimeout;
    return clearTimeout(marker);
  }
  try {
    return cachedClearTimeout(marker);
  } catch (e) {
    try {
      return cachedClearTimeout.call(null, marker);
    } catch (e2) {
      return cachedClearTimeout.call(this, marker);
    }
  }
}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;
function cleanUpNextTick() {
  if (!draining || !currentQueue) {
    return;
  }
  draining = false;
  if (currentQueue.length) {
    queue = currentQueue.concat(queue);
  } else {
    queueIndex = -1;
  }
  if (queue.length) {
    drainQueue();
  }
}
function drainQueue() {
  if (draining) {
    return;
  }
  var timeout = runTimeout(cleanUpNextTick);
  draining = true;
  var len = queue.length;
  while (len) {
    currentQueue = queue;
    queue = [];
    while (++queueIndex < len) {
      if (currentQueue) {
        currentQueue[queueIndex].run();
      }
    }
    queueIndex = -1;
    len = queue.length;
  }
  currentQueue = null;
  draining = false;
  runClearTimeout(timeout);
}
function nextTick(fun) {
  var args = new Array(arguments.length - 1);
  if (arguments.length > 1) {
    for (var i = 1; i < arguments.length; i++) {
      args[i - 1] = arguments[i];
    }
  }
  queue.push(new Item(fun, args));
  if (queue.length === 1 && !draining) {
    runTimeout(drainQueue);
  }
}
function Item(fun, array) {
  this.fun = fun;
  this.array = array;
}
Item.prototype.run = function() {
  this.fun.apply(null, this.array);
};
var title = "browser";
var platform = "browser";
var browser = true;
var argv = [];
var version = "";
var versions = {};
var release = {};
var config = {};
function noop() {
}
var on = noop;
var addListener = noop;
var once = noop;
var off = noop;
var removeListener = noop;
var removeAllListeners = noop;
var emit = noop;
function binding(name) {
  throw new Error("process.binding is not supported");
}
function cwd() {
  return "/";
}
function chdir(dir) {
  throw new Error("process.chdir is not supported");
}
function umask() {
  return 0;
}
var performance = globalContext.performance || {};
var performanceNow = performance.now || performance.mozNow || performance.msNow || performance.oNow || performance.webkitNow || function() {
  return new Date().getTime();
};
function hrtime(previousTimestamp) {
  var clocktime = performanceNow.call(performance) * 1e-3;
  var seconds = Math.floor(clocktime);
  var nanoseconds = Math.floor(clocktime % 1 * 1e9);
  if (previousTimestamp) {
    seconds = seconds - previousTimestamp[0];
    nanoseconds = nanoseconds - previousTimestamp[1];
    if (nanoseconds < 0) {
      seconds--;
      nanoseconds += 1e9;
    }
  }
  return [
    seconds,
    nanoseconds
  ];
}
var startTime = new Date();
function uptime() {
  var currentTime = new Date();
  var dif = currentTime - startTime;
  return dif / 1e3;
}
var process = {
  nextTick,
  title,
  browser,
  env: {
    NODE_ENV: "production"
  },
  argv,
  version,
  versions,
  on,
  addListener,
  once,
  off,
  removeListener,
  removeAllListeners,
  emit,
  binding,
  cwd,
  chdir,
  umask,
  hrtime,
  platform,
  release,
  config,
  uptime
};
function createCommonjsModule(fn, basedir, module2) {
  return module2 = {
    path: basedir,
    exports: {},
    require: function(path, base) {
      return commonjsRequire(path, base === void 0 || base === null ? module2.path : base);
    }
  }, fn(module2, module2.exports), module2.exports;
}
function commonjsRequire() {
  throw new Error("Dynamic requires are not currently supported by @rollup/plugin-commonjs");
}
function setup(env) {
  createDebug.debug = createDebug;
  createDebug.default = createDebug;
  createDebug.coerce = coerce;
  createDebug.disable = disable;
  createDebug.enable = enable;
  createDebug.enabled = enabled;
  createDebug.humanize = ms;
  createDebug.destroy = destroy2;
  Object.keys(env).forEach((key) => {
    createDebug[key] = env[key];
  });
  createDebug.names = [];
  createDebug.skips = [];
  createDebug.formatters = {};
  function selectColor(namespace) {
    let hash = 0;
    for (let i = 0; i < namespace.length; i++) {
      hash = (hash << 5) - hash + namespace.charCodeAt(i);
      hash |= 0;
    }
    return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
  }
  createDebug.selectColor = selectColor;
  function createDebug(namespace) {
    let prevTime;
    let enableOverride = null;
    let namespacesCache;
    let enabledCache;
    function debug3(...args) {
      if (!debug3.enabled) {
        return;
      }
      const self2 = debug3;
      const curr = Number(new Date());
      const ms2 = curr - (prevTime || curr);
      self2.diff = ms2;
      self2.prev = prevTime;
      self2.curr = curr;
      prevTime = curr;
      args[0] = createDebug.coerce(args[0]);
      if (typeof args[0] !== "string") {
        args.unshift("%O");
      }
      let index = 0;
      args[0] = args[0].replace(/%([a-zA-Z%])/g, (match2, format) => {
        if (match2 === "%%") {
          return "%";
        }
        index++;
        const formatter = createDebug.formatters[format];
        if (typeof formatter === "function") {
          const val = args[index];
          match2 = formatter.call(self2, val);
          args.splice(index, 1);
          index--;
        }
        return match2;
      });
      createDebug.formatArgs.call(self2, args);
      const logFn = self2.log || createDebug.log;
      logFn.apply(self2, args);
    }
    debug3.namespace = namespace;
    debug3.useColors = createDebug.useColors();
    debug3.color = createDebug.selectColor(namespace);
    debug3.extend = extend;
    debug3.destroy = createDebug.destroy;
    Object.defineProperty(debug3, "enabled", {
      enumerable: true,
      configurable: false,
      get: () => {
        if (enableOverride !== null) {
          return enableOverride;
        }
        if (namespacesCache !== createDebug.namespaces) {
          namespacesCache = createDebug.namespaces;
          enabledCache = createDebug.enabled(namespace);
        }
        return enabledCache;
      },
      set: (v) => {
        enableOverride = v;
      }
    });
    if (typeof createDebug.init === "function") {
      createDebug.init(debug3);
    }
    return debug3;
  }
  function extend(namespace, delimiter) {
    const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
    newDebug.log = this.log;
    return newDebug;
  }
  function enable(namespaces) {
    createDebug.save(namespaces);
    createDebug.namespaces = namespaces;
    createDebug.names = [];
    createDebug.skips = [];
    let i;
    const split = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
    const len = split.length;
    for (i = 0; i < len; i++) {
      if (!split[i]) {
        continue;
      }
      namespaces = split[i].replace(/\*/g, ".*?");
      if (namespaces[0] === "-") {
        createDebug.skips.push(new RegExp("^" + namespaces.slice(1) + "$"));
      } else {
        createDebug.names.push(new RegExp("^" + namespaces + "$"));
      }
    }
  }
  function disable() {
    const namespaces = [
      ...createDebug.names.map(toNamespace),
      ...createDebug.skips.map(toNamespace).map((namespace) => "-" + namespace)
    ].join(",");
    createDebug.enable("");
    return namespaces;
  }
  function enabled(name) {
    if (name[name.length - 1] === "*") {
      return true;
    }
    let i;
    let len;
    for (i = 0, len = createDebug.skips.length; i < len; i++) {
      if (createDebug.skips[i].test(name)) {
        return false;
      }
    }
    for (i = 0, len = createDebug.names.length; i < len; i++) {
      if (createDebug.names[i].test(name)) {
        return true;
      }
    }
    return false;
  }
  function toNamespace(regexp) {
    return regexp.toString().substring(2, regexp.toString().length - 2).replace(/\.\*\?$/, "*");
  }
  function coerce(val) {
    if (val instanceof Error) {
      return val.stack || val.message;
    }
    return val;
  }
  function destroy2() {
    console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
  }
  createDebug.enable(createDebug.load());
  return createDebug;
}
var common = setup;
var browser$1 = createCommonjsModule(function(module2, exports) {
  exports.formatArgs = formatArgs2;
  exports.save = save2;
  exports.load = load2;
  exports.useColors = useColors2;
  exports.storage = localstorage();
  exports.destroy = (() => {
    let warned = false;
    return () => {
      if (!warned) {
        warned = true;
        console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
      }
    };
  })();
  exports.colors = [
    "#0000CC",
    "#0000FF",
    "#0033CC",
    "#0033FF",
    "#0066CC",
    "#0066FF",
    "#0099CC",
    "#0099FF",
    "#00CC00",
    "#00CC33",
    "#00CC66",
    "#00CC99",
    "#00CCCC",
    "#00CCFF",
    "#3300CC",
    "#3300FF",
    "#3333CC",
    "#3333FF",
    "#3366CC",
    "#3366FF",
    "#3399CC",
    "#3399FF",
    "#33CC00",
    "#33CC33",
    "#33CC66",
    "#33CC99",
    "#33CCCC",
    "#33CCFF",
    "#6600CC",
    "#6600FF",
    "#6633CC",
    "#6633FF",
    "#66CC00",
    "#66CC33",
    "#9900CC",
    "#9900FF",
    "#9933CC",
    "#9933FF",
    "#99CC00",
    "#99CC33",
    "#CC0000",
    "#CC0033",
    "#CC0066",
    "#CC0099",
    "#CC00CC",
    "#CC00FF",
    "#CC3300",
    "#CC3333",
    "#CC3366",
    "#CC3399",
    "#CC33CC",
    "#CC33FF",
    "#CC6600",
    "#CC6633",
    "#CC9900",
    "#CC9933",
    "#CCCC00",
    "#CCCC33",
    "#FF0000",
    "#FF0033",
    "#FF0066",
    "#FF0099",
    "#FF00CC",
    "#FF00FF",
    "#FF3300",
    "#FF3333",
    "#FF3366",
    "#FF3399",
    "#FF33CC",
    "#FF33FF",
    "#FF6600",
    "#FF6633",
    "#FF9900",
    "#FF9933",
    "#FFCC00",
    "#FFCC33"
  ];
  function useColors2() {
    if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
      return true;
    }
    if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
      return false;
    }
    return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
  }
  function formatArgs2(args) {
    args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module2.exports.humanize(this.diff);
    if (!this.useColors) {
      return;
    }
    const c = "color: " + this.color;
    args.splice(1, 0, c, "color: inherit");
    let index = 0;
    let lastC = 0;
    args[0].replace(/%[a-zA-Z%]/g, (match2) => {
      if (match2 === "%%") {
        return;
      }
      index++;
      if (match2 === "%c") {
        lastC = index;
      }
    });
    args.splice(lastC, 0, c);
  }
  exports.log = console.debug || console.log || (() => {
  });
  function save2(namespaces) {
    try {
      if (namespaces) {
        exports.storage.setItem("debug", namespaces);
      } else {
        exports.storage.removeItem("debug");
      }
    } catch (error) {
    }
  }
  function load2() {
    let r;
    try {
      r = exports.storage.getItem("debug");
    } catch (error) {
    }
    if (!r && typeof process !== "undefined" && "env" in process) {
      r = process.env.DEBUG;
    }
    return r;
  }
  function localstorage() {
    try {
      return localStorage;
    } catch (error) {
    }
  }
  module2.exports = common(exports);
  const { formatters } = module2.exports;
  formatters.j = function(v) {
    try {
      return JSON.stringify(v);
    } catch (error) {
      return "[UnexpectedJSONParseError]: " + error.message;
    }
  };
});
browser$1.colors;
browser$1.destroy;
browser$1.formatArgs;
browser$1.load;
browser$1.log;
browser$1.save;
browser$1.storage;
browser$1.useColors;
var itrToStream = (itr) => {
  const it = itr[Symbol.asyncIterator]();
  return new ReadableStream({
    async pull(controller) {
      const chunk = await it.next();
      if (chunk.done)
        controller.close();
      else
        controller.enqueue(chunk.value);
    }
  });
};
var baseFetchConfig = (_apiRoot) => ({});
var GrammyError = class extends Error {
  constructor(message, err, method, payload) {
    var _a;
    super(`${message} (${err.error_code}: ${err.description})`);
    __publicField(this, "method");
    __publicField(this, "payload");
    __publicField(this, "ok");
    __publicField(this, "error_code");
    __publicField(this, "description");
    __publicField(this, "parameters");
    this.method = method;
    this.payload = payload;
    this.ok = false;
    this.name = "GrammyError";
    this.error_code = err.error_code;
    this.description = err.description;
    this.parameters = (_a = err.parameters) != null ? _a : {};
  }
};
function toGrammyError(err, method, payload) {
  return new GrammyError(`Call to '${method}' failed!`, err, method, payload);
}
var HttpError = class extends Error {
  constructor(message, error) {
    super(message);
    __publicField(this, "error");
    this.error = error;
    this.name = "HttpError";
  }
};
function isTelegramError(err) {
  return typeof err === "object" && err !== null && "status" in err && "statusText" in err;
}
function toHttpError(method, sensitiveLogs) {
  return (err) => {
    let msg = `Network request for '${method}' failed!`;
    if (isTelegramError(err))
      msg += ` (${err.status}: ${err.statusText})`;
    if (sensitiveLogs && err instanceof Error)
      msg += ` ${err.message}`;
    throw new HttpError(msg, err);
  };
}
var osType = (() => {
  var _a, _b, _c;
  const { Deno } = globalThis;
  if (typeof ((_a = Deno == null ? void 0 : Deno.build) == null ? void 0 : _a.os) === "string") {
    return Deno.build.os;
  }
  const { navigator: navigator1 } = globalThis;
  if ((_c = (_b = navigator1 == null ? void 0 : navigator1.appVersion) == null ? void 0 : _b.includes) == null ? void 0 : _c.call(_b, "Win")) {
    return "windows";
  }
  return "linux";
})();
var isWindows = osType === "windows";
function assertPath(path) {
  if (typeof path !== "string") {
    throw new TypeError(`Path must be a string. Received ${JSON.stringify(path)}`);
  }
}
function stripSuffix(name, suffix) {
  if (suffix.length >= name.length) {
    return name;
  }
  const lenDiff = name.length - suffix.length;
  for (let i = suffix.length - 1; i >= 0; --i) {
    if (name.charCodeAt(lenDiff + i) !== suffix.charCodeAt(i)) {
      return name;
    }
  }
  return name.slice(0, -suffix.length);
}
function lastPathSegment(path, isSep, start = 0) {
  let matchedNonSeparator = false;
  let end = path.length;
  for (let i = path.length - 1; i >= start; --i) {
    if (isSep(path.charCodeAt(i))) {
      if (matchedNonSeparator) {
        start = i + 1;
        break;
      }
    } else if (!matchedNonSeparator) {
      matchedNonSeparator = true;
      end = i + 1;
    }
  }
  return path.slice(start, end);
}
function assertArgs(path, suffix) {
  assertPath(path);
  if (path.length === 0)
    return path;
  if (typeof suffix !== "string") {
    throw new TypeError(`Suffix must be a string. Received ${JSON.stringify(suffix)}`);
  }
}
function stripTrailingSeparators(segment, isSep) {
  if (segment.length <= 1) {
    return segment;
  }
  let end = segment.length;
  for (let i = segment.length - 1; i > 0; i--) {
    if (isSep(segment.charCodeAt(i))) {
      end = i;
    } else {
      break;
    }
  }
  return segment.slice(0, end);
}
function isPosixPathSeparator(code) {
  return code === 47;
}
function basename(path, suffix = "") {
  assertArgs(path, suffix);
  const lastSegment = lastPathSegment(path, isPosixPathSeparator);
  const strippedSegment = stripTrailingSeparators(lastSegment, isPosixPathSeparator);
  return suffix ? stripSuffix(strippedSegment, suffix) : strippedSegment;
}
function isPathSeparator(code) {
  return code === 47 || code === 92;
}
function isWindowsDeviceRoot(code) {
  return code >= 97 && code <= 122 || code >= 65 && code <= 90;
}
function basename1(path, suffix = "") {
  assertArgs(path, suffix);
  let start = 0;
  if (path.length >= 2) {
    const drive = path.charCodeAt(0);
    if (isWindowsDeviceRoot(drive)) {
      if (path.charCodeAt(1) === 58)
        start = 2;
    }
  }
  const lastSegment = lastPathSegment(path, isPathSeparator, start);
  const strippedSegment = stripTrailingSeparators(lastSegment, isPathSeparator);
  return suffix ? stripSuffix(strippedSegment, suffix) : strippedSegment;
}
function basename2(path, suffix = "") {
  return isWindows ? basename1(path, suffix) : basename(path, suffix);
}
var InputFile = class {
  constructor(file, filename) {
    __publicField(this, "consumed", false);
    __publicField(this, "fileData");
    __publicField(this, "filename");
    this.fileData = file;
    filename != null ? filename : filename = this.guessFilename(file);
    this.filename = filename;
  }
  guessFilename(file) {
    if (typeof file === "string")
      return basename2(file);
    if (typeof file !== "object")
      return void 0;
    if ("url" in file)
      return basename2(file.url);
    if (!(file instanceof URL))
      return void 0;
    return basename2(file.pathname) || basename2(file.hostname);
  }
  toRaw() {
    if (this.consumed) {
      throw new Error("Cannot reuse InputFile data source!");
    }
    const data = this.fileData;
    if (data instanceof Blob)
      return data.stream();
    if (data instanceof URL)
      return fetchFile(data);
    if ("url" in data)
      return fetchFile(data.url);
    if (!(data instanceof Uint8Array))
      this.consumed = true;
    return data;
  }
};
async function* fetchFile(url) {
  const { body } = await fetch(url);
  if (body === null) {
    throw new Error(`Download failed, no response body from '${url}'`);
  }
  yield* body;
}
function requiresFormDataUpload(payload) {
  return payload instanceof InputFile || typeof payload === "object" && payload !== null && Object.values(payload).some((v) => Array.isArray(v) ? v.some(requiresFormDataUpload) : v instanceof InputFile || requiresFormDataUpload(v));
}
function str(value) {
  return JSON.stringify(value, (_, v) => v != null ? v : void 0);
}
function createJsonPayload(payload) {
  return {
    method: "POST",
    headers: {
      "content-type": "application/json",
      connection: "keep-alive"
    },
    body: str(payload)
  };
}
async function* protectItr(itr, onError) {
  try {
    yield* itr;
  } catch (err) {
    onError(err);
  }
}
function createFormDataPayload(payload, onError) {
  const boundary = createBoundary();
  const itr = payloadToMultipartItr(payload, boundary);
  const safeItr = protectItr(itr, onError);
  const stream = itrToStream(safeItr);
  return {
    method: "POST",
    headers: {
      "content-type": `multipart/form-data; boundary=${boundary}`,
      connection: "keep-alive"
    },
    body: stream
  };
}
function createBoundary() {
  return "----------" + randomId(32);
}
function randomId(length = 16) {
  return Array.from(Array(length)).map(() => Math.random().toString(36)[2] || 0).join("");
}
var enc = new TextEncoder();
async function* payloadToMultipartItr(payload, boundary) {
  const files = extractFiles(payload);
  yield enc.encode(`--${boundary}\r
`);
  const separator = enc.encode(`\r
--${boundary}\r
`);
  let first = true;
  for (const [key, value] of Object.entries(payload)) {
    if (value == null)
      continue;
    if (!first)
      yield separator;
    yield valuePart(key, typeof value === "object" ? str(value) : value);
    first = false;
  }
  for (const { id, origin, file } of files) {
    if (!first)
      yield separator;
    yield* filePart(id, origin, file);
    first = false;
  }
  yield enc.encode(`\r
--${boundary}--\r
`);
}
function extractFiles(value) {
  if (typeof value !== "object" || value === null)
    return [];
  return Object.entries(value).flatMap(([k, v]) => {
    if (Array.isArray(v))
      return v.flatMap((p) => extractFiles(p));
    else if (v instanceof InputFile) {
      const id = randomId();
      Object.assign(value, {
        [k]: `attach://${id}`
      });
      const origin = k === "media" && "type" in value && typeof value.type === "string" ? value.type : k;
      return {
        id,
        origin,
        file: v
      };
    } else
      return extractFiles(v);
  });
}
function valuePart(key, value) {
  return enc.encode(`content-disposition:form-data;name="${key}"\r
\r
${value}`);
}
async function* filePart(id, origin, input) {
  const filename = input.filename || `${origin}.${getExt(origin)}`;
  if (filename.includes("\r") || filename.includes("\n")) {
    throw new Error(`File paths cannot contain carriage-return (\\r) or newline (\\n) characters! Filename for property '${origin}' was:
"""
${filename}
"""`);
  }
  yield enc.encode(`content-disposition:form-data;name="${id}";filename=${filename}\r
content-type:application/octet-stream\r
\r
`);
  const data = await input.toRaw();
  if (data instanceof Uint8Array)
    yield data;
  else
    yield* data;
}
function getExt(key) {
  switch (key) {
    case "certificate":
      return "pem";
    case "photo":
    case "thumbnail":
      return "jpg";
    case "voice":
      return "ogg";
    case "audio":
      return "mp3";
    case "animation":
    case "video":
    case "video_note":
      return "mp4";
    case "sticker":
      return "webp";
    default:
      return "dat";
  }
}
var debug = browser$1("grammy:core");
function concatTransformer(prev, trans) {
  return (method, payload, signal) => trans(prev, method, payload, signal);
}
var ApiClient = class {
  constructor(token, options = {}, webhookReplyEnvelope = {}) {
    __publicField(this, "token");
    __publicField(this, "webhookReplyEnvelope");
    __publicField(this, "options");
    __publicField(this, "hasUsedWebhookReply");
    __publicField(this, "installedTransformers");
    __publicField(this, "call");
    var _a, _b, _c, _d, _e, _f;
    this.token = token;
    this.webhookReplyEnvelope = webhookReplyEnvelope;
    this.hasUsedWebhookReply = false;
    this.installedTransformers = [];
    this.call = async (method, p, signal) => {
      const payload = p != null ? p : {};
      debug(`Calling ${method}`);
      if (signal !== void 0)
        validateSignal(method, payload, signal);
      const opts = this.options;
      const formDataRequired = requiresFormDataUpload(payload);
      if (this.webhookReplyEnvelope.send !== void 0 && !this.hasUsedWebhookReply && !formDataRequired && opts.canUseWebhookReply(method)) {
        this.hasUsedWebhookReply = true;
        const config3 = createJsonPayload({
          ...payload,
          method
        });
        await this.webhookReplyEnvelope.send(config3.body);
        return {
          ok: true,
          result: true
        };
      }
      const controller = createAbortControllerFromSignal(signal);
      const timeout = createTimeout(controller, opts.timeoutSeconds, method);
      const streamErr = createStreamError(controller);
      const url = opts.buildUrl(opts.apiRoot, this.token, method, opts.environment);
      const config2 = formDataRequired ? createFormDataPayload(payload, (err) => streamErr.catch(err)) : createJsonPayload(payload);
      const sig = controller.signal;
      const options2 = {
        ...opts.baseFetchConfig,
        signal: sig,
        ...config2
      };
      const successPromise = fetch(url instanceof URL ? url.href : url, options2).catch(toHttpError(method, opts.sensitiveLogs));
      const operations = [
        successPromise,
        streamErr.promise,
        timeout.promise
      ];
      try {
        const res = await Promise.race(operations);
        return await res.json();
      } finally {
        if (timeout.handle !== void 0)
          clearTimeout(timeout.handle);
      }
    };
    const apiRoot = (_a = options.apiRoot) != null ? _a : "https://api.telegram.org";
    const environment = (_b = options.environment) != null ? _b : "prod";
    this.options = {
      apiRoot,
      environment,
      buildUrl: (_c = options.buildUrl) != null ? _c : defaultBuildUrl,
      timeoutSeconds: (_d = options.timeoutSeconds) != null ? _d : 500,
      baseFetchConfig: {
        ...baseFetchConfig(apiRoot),
        ...options.baseFetchConfig
      },
      canUseWebhookReply: (_e = options.canUseWebhookReply) != null ? _e : () => false,
      sensitiveLogs: (_f = options.sensitiveLogs) != null ? _f : false
    };
    if (this.options.apiRoot.endsWith("/")) {
      throw new Error(`Remove the trailing '/' from the 'apiRoot' option (use '${this.options.apiRoot.substring(0, this.options.apiRoot.length - 1)}' instead of '${this.options.apiRoot}')`);
    }
  }
  use(...transformers) {
    this.call = transformers.reduce(concatTransformer, this.call);
    this.installedTransformers.push(...transformers);
    return this;
  }
  async callApi(method, payload, signal) {
    const data = await this.call(method, payload, signal);
    if (data.ok)
      return data.result;
    else
      throw toGrammyError(data, method, payload);
  }
};
function createRawApi(token, options, webhookReplyEnvelope) {
  const client = new ApiClient(token, options, webhookReplyEnvelope);
  const proxyHandler = {
    get(_, m2) {
      return m2 === "toJSON" ? "__internal" : client.callApi.bind(client, m2);
    },
    ...proxyMethods
  };
  const raw = new Proxy({}, proxyHandler);
  const installedTransformers = client.installedTransformers;
  const api = {
    raw,
    installedTransformers,
    use: (...t) => {
      client.use(...t);
      return api;
    }
  };
  return api;
}
var defaultBuildUrl = (root, token, method, env) => {
  const prefix = env === "test" ? "test/" : "";
  return `${root}/bot${token}/${prefix}${method}`;
};
var proxyMethods = {
  set() {
    return false;
  },
  defineProperty() {
    return false;
  },
  deleteProperty() {
    return false;
  },
  ownKeys() {
    return [];
  }
};
function createTimeout(controller, seconds, method) {
  let handle = void 0;
  const promise = new Promise((_, reject) => {
    handle = setTimeout(() => {
      const msg = `Request to '${method}' timed out after ${seconds} seconds`;
      reject(new Error(msg));
      controller.abort();
    }, 1e3 * seconds);
  });
  return {
    promise,
    handle
  };
}
function createStreamError(abortController) {
  let onError = (err) => {
    throw err;
  };
  const promise = new Promise((_, reject) => {
    onError = (err) => {
      reject(err);
      abortController.abort();
    };
  });
  return {
    promise,
    catch: onError
  };
}
function createAbortControllerFromSignal(signal) {
  const abortController = new AbortController();
  if (signal === void 0)
    return abortController;
  const sig = signal;
  function abort() {
    abortController.abort();
    sig.removeEventListener("abort", abort);
  }
  if (sig.aborted)
    abort();
  else
    sig.addEventListener("abort", abort);
  return {
    abort,
    signal: abortController.signal
  };
}
function validateSignal(method, payload, signal) {
  if (typeof (signal == null ? void 0 : signal.addEventListener) === "function") {
    return;
  }
  let payload0 = JSON.stringify(payload);
  if (payload0.length > 20) {
    payload0 = payload0.substring(0, 16) + " ...";
  }
  let payload1 = JSON.stringify(signal);
  if (payload1.length > 20) {
    payload1 = payload1.substring(0, 16) + " ...";
  }
  throw new Error(`Incorrect abort signal instance found! You passed two payloads to '${method}' but you should merge the second one containing '${payload1}' into the first one containing '${payload0}'! If you are using context shortcuts, you may want to use a method on 'ctx.api' instead.

If you want to prevent such mistakes in the future, consider using TypeScript. https://www.typescriptlang.org/`);
}
var Api = class {
  constructor(token, config2, webhookReplyEnvelope) {
    __publicField(this, "raw");
    __publicField(this, "config");
    const { raw, use, installedTransformers } = createRawApi(token, config2, webhookReplyEnvelope);
    this.raw = raw;
    this.config = {
      use,
      installedTransformers: () => [
        ...installedTransformers
      ]
    };
  }
  getUpdates(other, signal) {
    return this.raw.getUpdates({
      ...other
    }, signal);
  }
  setWebhook(url, other, signal) {
    return this.raw.setWebhook({
      url,
      ...other
    }, signal);
  }
  deleteWebhook(other, signal) {
    return this.raw.deleteWebhook({
      ...other
    }, signal);
  }
  getWebhookInfo(signal) {
    return this.raw.getWebhookInfo(signal);
  }
  getMe(signal) {
    return this.raw.getMe(signal);
  }
  logOut(signal) {
    return this.raw.logOut(signal);
  }
  close(signal) {
    return this.raw.close(signal);
  }
  sendMessage(chat_id, text, other, signal) {
    return this.raw.sendMessage({
      chat_id,
      text,
      ...other
    }, signal);
  }
  forwardMessage(chat_id, from_chat_id, message_id, other, signal) {
    return this.raw.forwardMessage({
      chat_id,
      from_chat_id,
      message_id,
      ...other
    }, signal);
  }
  forwardMessages(chat_id, from_chat_id, message_ids, other, signal) {
    return this.raw.forwardMessages({
      chat_id,
      from_chat_id,
      message_ids,
      ...other
    }, signal);
  }
  copyMessage(chat_id, from_chat_id, message_id, other, signal) {
    return this.raw.copyMessage({
      chat_id,
      from_chat_id,
      message_id,
      ...other
    }, signal);
  }
  copyMessages(chat_id, from_chat_id, message_ids, other, signal) {
    return this.raw.copyMessages({
      chat_id,
      from_chat_id,
      message_ids,
      ...other
    }, signal);
  }
  sendPhoto(chat_id, photo, other, signal) {
    return this.raw.sendPhoto({
      chat_id,
      photo,
      ...other
    }, signal);
  }
  sendAudio(chat_id, audio, other, signal) {
    return this.raw.sendAudio({
      chat_id,
      audio,
      ...other
    }, signal);
  }
  sendDocument(chat_id, document1, other, signal) {
    return this.raw.sendDocument({
      chat_id,
      document: document1,
      ...other
    }, signal);
  }
  sendVideo(chat_id, video, other, signal) {
    return this.raw.sendVideo({
      chat_id,
      video,
      ...other
    }, signal);
  }
  sendAnimation(chat_id, animation, other, signal) {
    return this.raw.sendAnimation({
      chat_id,
      animation,
      ...other
    }, signal);
  }
  sendVoice(chat_id, voice, other, signal) {
    return this.raw.sendVoice({
      chat_id,
      voice,
      ...other
    }, signal);
  }
  sendVideoNote(chat_id, video_note, other, signal) {
    return this.raw.sendVideoNote({
      chat_id,
      video_note,
      ...other
    }, signal);
  }
  sendMediaGroup(chat_id, media, other, signal) {
    return this.raw.sendMediaGroup({
      chat_id,
      media,
      ...other
    }, signal);
  }
  sendLocation(chat_id, latitude, longitude, other, signal) {
    return this.raw.sendLocation({
      chat_id,
      latitude,
      longitude,
      ...other
    }, signal);
  }
  editMessageLiveLocation(chat_id, message_id, latitude, longitude, other, signal) {
    return this.raw.editMessageLiveLocation({
      chat_id,
      message_id,
      latitude,
      longitude,
      ...other
    }, signal);
  }
  editMessageLiveLocationInline(inline_message_id, latitude, longitude, other, signal) {
    return this.raw.editMessageLiveLocation({
      inline_message_id,
      latitude,
      longitude,
      ...other
    }, signal);
  }
  stopMessageLiveLocation(chat_id, message_id, other, signal) {
    return this.raw.stopMessageLiveLocation({
      chat_id,
      message_id,
      ...other
    }, signal);
  }
  stopMessageLiveLocationInline(inline_message_id, other, signal) {
    return this.raw.stopMessageLiveLocation({
      inline_message_id,
      ...other
    }, signal);
  }
  sendVenue(chat_id, latitude, longitude, title2, address, other, signal) {
    return this.raw.sendVenue({
      chat_id,
      latitude,
      longitude,
      title: title2,
      address,
      ...other
    }, signal);
  }
  sendContact(chat_id, phone_number, first_name, other, signal) {
    return this.raw.sendContact({
      chat_id,
      phone_number,
      first_name,
      ...other
    }, signal);
  }
  sendPoll(chat_id, question, options, other, signal) {
    return this.raw.sendPoll({
      chat_id,
      question,
      options,
      ...other
    }, signal);
  }
  sendDice(chat_id, emoji, other, signal) {
    return this.raw.sendDice({
      chat_id,
      emoji,
      ...other
    }, signal);
  }
  setMessageReaction(chat_id, message_id, reaction, other, signal) {
    return this.raw.setMessageReaction({
      chat_id,
      message_id,
      reaction,
      ...other
    }, signal);
  }
  sendChatAction(chat_id, action, other, signal) {
    return this.raw.sendChatAction({
      chat_id,
      action,
      ...other
    }, signal);
  }
  getUserProfilePhotos(user_id, other, signal) {
    return this.raw.getUserProfilePhotos({
      user_id,
      ...other
    }, signal);
  }
  getUserChatBoosts(chat_id, user_id, signal) {
    return this.raw.getUserChatBoosts({
      chat_id,
      user_id
    }, signal);
  }
  getFile(file_id, signal) {
    return this.raw.getFile({
      file_id
    }, signal);
  }
  kickChatMember(...args) {
    return this.banChatMember(...args);
  }
  banChatMember(chat_id, user_id, other, signal) {
    return this.raw.banChatMember({
      chat_id,
      user_id,
      ...other
    }, signal);
  }
  unbanChatMember(chat_id, user_id, other, signal) {
    return this.raw.unbanChatMember({
      chat_id,
      user_id,
      ...other
    }, signal);
  }
  restrictChatMember(chat_id, user_id, permissions, other, signal) {
    return this.raw.restrictChatMember({
      chat_id,
      user_id,
      permissions,
      ...other
    }, signal);
  }
  promoteChatMember(chat_id, user_id, other, signal) {
    return this.raw.promoteChatMember({
      chat_id,
      user_id,
      ...other
    }, signal);
  }
  setChatAdministratorCustomTitle(chat_id, user_id, custom_title, signal) {
    return this.raw.setChatAdministratorCustomTitle({
      chat_id,
      user_id,
      custom_title
    }, signal);
  }
  banChatSenderChat(chat_id, sender_chat_id, signal) {
    return this.raw.banChatSenderChat({
      chat_id,
      sender_chat_id
    }, signal);
  }
  unbanChatSenderChat(chat_id, sender_chat_id, signal) {
    return this.raw.unbanChatSenderChat({
      chat_id,
      sender_chat_id
    }, signal);
  }
  setChatPermissions(chat_id, permissions, signal) {
    return this.raw.setChatPermissions({
      chat_id,
      permissions
    }, signal);
  }
  exportChatInviteLink(chat_id, signal) {
    return this.raw.exportChatInviteLink({
      chat_id
    }, signal);
  }
  createChatInviteLink(chat_id, other, signal) {
    return this.raw.createChatInviteLink({
      chat_id,
      ...other
    }, signal);
  }
  editChatInviteLink(chat_id, invite_link, other, signal) {
    return this.raw.editChatInviteLink({
      chat_id,
      invite_link,
      ...other
    }, signal);
  }
  revokeChatInviteLink(chat_id, invite_link, signal) {
    return this.raw.revokeChatInviteLink({
      chat_id,
      invite_link
    }, signal);
  }
  approveChatJoinRequest(chat_id, user_id, signal) {
    return this.raw.approveChatJoinRequest({
      chat_id,
      user_id
    }, signal);
  }
  declineChatJoinRequest(chat_id, user_id, signal) {
    return this.raw.declineChatJoinRequest({
      chat_id,
      user_id
    }, signal);
  }
  setChatPhoto(chat_id, photo, signal) {
    return this.raw.setChatPhoto({
      chat_id,
      photo
    }, signal);
  }
  deleteChatPhoto(chat_id, signal) {
    return this.raw.deleteChatPhoto({
      chat_id
    }, signal);
  }
  setChatTitle(chat_id, title2, signal) {
    return this.raw.setChatTitle({
      chat_id,
      title: title2
    }, signal);
  }
  setChatDescription(chat_id, description, signal) {
    return this.raw.setChatDescription({
      chat_id,
      description
    }, signal);
  }
  pinChatMessage(chat_id, message_id, other, signal) {
    return this.raw.pinChatMessage({
      chat_id,
      message_id,
      ...other
    }, signal);
  }
  unpinChatMessage(chat_id, message_id, signal) {
    return this.raw.unpinChatMessage({
      chat_id,
      message_id
    }, signal);
  }
  unpinAllChatMessages(chat_id, signal) {
    return this.raw.unpinAllChatMessages({
      chat_id
    }, signal);
  }
  leaveChat(chat_id, signal) {
    return this.raw.leaveChat({
      chat_id
    }, signal);
  }
  getChat(chat_id, signal) {
    return this.raw.getChat({
      chat_id
    }, signal);
  }
  getChatAdministrators(chat_id, signal) {
    return this.raw.getChatAdministrators({
      chat_id
    }, signal);
  }
  getChatMembersCount(...args) {
    return this.getChatMemberCount(...args);
  }
  getChatMemberCount(chat_id, signal) {
    return this.raw.getChatMemberCount({
      chat_id
    }, signal);
  }
  getChatMember(chat_id, user_id, signal) {
    return this.raw.getChatMember({
      chat_id,
      user_id
    }, signal);
  }
  setChatStickerSet(chat_id, sticker_set_name, signal) {
    return this.raw.setChatStickerSet({
      chat_id,
      sticker_set_name
    }, signal);
  }
  deleteChatStickerSet(chat_id, signal) {
    return this.raw.deleteChatStickerSet({
      chat_id
    }, signal);
  }
  getForumTopicIconStickers(signal) {
    return this.raw.getForumTopicIconStickers(signal);
  }
  createForumTopic(chat_id, name, other, signal) {
    return this.raw.createForumTopic({
      chat_id,
      name,
      ...other
    }, signal);
  }
  editForumTopic(chat_id, message_thread_id, other, signal) {
    return this.raw.editForumTopic({
      chat_id,
      message_thread_id,
      ...other
    }, signal);
  }
  closeForumTopic(chat_id, message_thread_id, signal) {
    return this.raw.closeForumTopic({
      chat_id,
      message_thread_id
    }, signal);
  }
  reopenForumTopic(chat_id, message_thread_id, signal) {
    return this.raw.reopenForumTopic({
      chat_id,
      message_thread_id
    }, signal);
  }
  deleteForumTopic(chat_id, message_thread_id, signal) {
    return this.raw.deleteForumTopic({
      chat_id,
      message_thread_id
    }, signal);
  }
  unpinAllForumTopicMessages(chat_id, message_thread_id, signal) {
    return this.raw.unpinAllForumTopicMessages({
      chat_id,
      message_thread_id
    }, signal);
  }
  editGeneralForumTopic(chat_id, name, signal) {
    return this.raw.editGeneralForumTopic({
      chat_id,
      name
    }, signal);
  }
  closeGeneralForumTopic(chat_id, signal) {
    return this.raw.closeGeneralForumTopic({
      chat_id
    }, signal);
  }
  reopenGeneralForumTopic(chat_id, signal) {
    return this.raw.reopenGeneralForumTopic({
      chat_id
    }, signal);
  }
  hideGeneralForumTopic(chat_id, signal) {
    return this.raw.hideGeneralForumTopic({
      chat_id
    }, signal);
  }
  unhideGeneralForumTopic(chat_id, signal) {
    return this.raw.unhideGeneralForumTopic({
      chat_id
    }, signal);
  }
  unpinAllGeneralForumTopicMessages(chat_id, signal) {
    return this.raw.unpinAllGeneralForumTopicMessages({
      chat_id
    }, signal);
  }
  answerCallbackQuery(callback_query_id, other, signal) {
    return this.raw.answerCallbackQuery({
      callback_query_id,
      ...other
    }, signal);
  }
  setMyName(name, other, signal) {
    return this.raw.setMyName({
      name,
      ...other
    }, signal);
  }
  getMyName(other, signal) {
    return this.raw.getMyName(other != null ? other : {}, signal);
  }
  setMyCommands(commands, other, signal) {
    return this.raw.setMyCommands({
      commands,
      ...other
    }, signal);
  }
  deleteMyCommands(other, signal) {
    return this.raw.deleteMyCommands({
      ...other
    }, signal);
  }
  getMyCommands(other, signal) {
    return this.raw.getMyCommands({
      ...other
    }, signal);
  }
  setMyDescription(description, other, signal) {
    return this.raw.setMyDescription({
      description,
      ...other
    }, signal);
  }
  getMyDescription(other, signal) {
    return this.raw.getMyDescription({
      ...other
    }, signal);
  }
  setMyShortDescription(short_description, other, signal) {
    return this.raw.setMyShortDescription({
      short_description,
      ...other
    }, signal);
  }
  getMyShortDescription(other, signal) {
    return this.raw.getMyShortDescription({
      ...other
    }, signal);
  }
  setChatMenuButton(other, signal) {
    return this.raw.setChatMenuButton({
      ...other
    }, signal);
  }
  getChatMenuButton(other, signal) {
    return this.raw.getChatMenuButton({
      ...other
    }, signal);
  }
  setMyDefaultAdministratorRights(other, signal) {
    return this.raw.setMyDefaultAdministratorRights({
      ...other
    }, signal);
  }
  getMyDefaultAdministratorRights(other, signal) {
    return this.raw.getMyDefaultAdministratorRights({
      ...other
    }, signal);
  }
  editMessageText(chat_id, message_id, text, other, signal) {
    return this.raw.editMessageText({
      chat_id,
      message_id,
      text,
      ...other
    }, signal);
  }
  editMessageTextInline(inline_message_id, text, other, signal) {
    return this.raw.editMessageText({
      inline_message_id,
      text,
      ...other
    }, signal);
  }
  editMessageCaption(chat_id, message_id, other, signal) {
    return this.raw.editMessageCaption({
      chat_id,
      message_id,
      ...other
    }, signal);
  }
  editMessageCaptionInline(inline_message_id, other, signal) {
    return this.raw.editMessageCaption({
      inline_message_id,
      ...other
    }, signal);
  }
  editMessageMedia(chat_id, message_id, media, other, signal) {
    return this.raw.editMessageMedia({
      chat_id,
      message_id,
      media,
      ...other
    }, signal);
  }
  editMessageMediaInline(inline_message_id, media, other, signal) {
    return this.raw.editMessageMedia({
      inline_message_id,
      media,
      ...other
    }, signal);
  }
  editMessageReplyMarkup(chat_id, message_id, other, signal) {
    return this.raw.editMessageReplyMarkup({
      chat_id,
      message_id,
      ...other
    }, signal);
  }
  editMessageReplyMarkupInline(inline_message_id, other, signal) {
    return this.raw.editMessageReplyMarkup({
      inline_message_id,
      ...other
    }, signal);
  }
  stopPoll(chat_id, message_id, other, signal) {
    return this.raw.stopPoll({
      chat_id,
      message_id,
      ...other
    }, signal);
  }
  deleteMessage(chat_id, message_id, signal) {
    return this.raw.deleteMessage({
      chat_id,
      message_id
    }, signal);
  }
  deleteMessages(chat_id, message_ids, signal) {
    return this.raw.deleteMessages({
      chat_id,
      message_ids
    }, signal);
  }
  sendSticker(chat_id, sticker, other, signal) {
    return this.raw.sendSticker({
      chat_id,
      sticker,
      ...other
    }, signal);
  }
  getStickerSet(name, signal) {
    return this.raw.getStickerSet({
      name
    }, signal);
  }
  getCustomEmojiStickers(custom_emoji_ids, signal) {
    return this.raw.getCustomEmojiStickers({
      custom_emoji_ids
    }, signal);
  }
  uploadStickerFile(user_id, sticker_format, sticker, signal) {
    return this.raw.uploadStickerFile({
      user_id,
      sticker_format,
      sticker
    }, signal);
  }
  createNewStickerSet(user_id, name, title2, stickers, sticker_format, other, signal) {
    return this.raw.createNewStickerSet({
      user_id,
      name,
      title: title2,
      stickers,
      sticker_format,
      ...other
    }, signal);
  }
  addStickerToSet(user_id, name, sticker, signal) {
    return this.raw.addStickerToSet({
      user_id,
      name,
      sticker
    }, signal);
  }
  setStickerPositionInSet(sticker, position, signal) {
    return this.raw.setStickerPositionInSet({
      sticker,
      position
    }, signal);
  }
  deleteStickerFromSet(sticker, signal) {
    return this.raw.deleteStickerFromSet({
      sticker
    }, signal);
  }
  setStickerEmojiList(sticker, emoji_list, signal) {
    return this.raw.setStickerEmojiList({
      sticker,
      emoji_list
    }, signal);
  }
  setStickerKeywords(sticker, keywords, signal) {
    return this.raw.setStickerKeywords({
      sticker,
      keywords
    }, signal);
  }
  setStickerMaskPosition(sticker, mask_position, signal) {
    return this.raw.setStickerMaskPosition({
      sticker,
      mask_position
    }, signal);
  }
  setStickerSetTitle(name, title2, signal) {
    return this.raw.setStickerSetTitle({
      name,
      title: title2
    }, signal);
  }
  deleteStickerSet(name, signal) {
    return this.raw.deleteStickerSet({
      name
    }, signal);
  }
  setStickerSetThumbnail(name, user_id, thumbnail, signal) {
    return this.raw.setStickerSetThumbnail({
      name,
      user_id,
      thumbnail
    }, signal);
  }
  setCustomEmojiStickerSetThumbnail(name, custom_emoji_id, signal) {
    return this.raw.setCustomEmojiStickerSetThumbnail({
      name,
      custom_emoji_id
    }, signal);
  }
  answerInlineQuery(inline_query_id, results, other, signal) {
    return this.raw.answerInlineQuery({
      inline_query_id,
      results,
      ...other
    }, signal);
  }
  answerWebAppQuery(web_app_query_id, result, signal) {
    return this.raw.answerWebAppQuery({
      web_app_query_id,
      result
    }, signal);
  }
  sendInvoice(chat_id, title2, description, payload, provider_token, currency, prices, other, signal) {
    return this.raw.sendInvoice({
      chat_id,
      title: title2,
      description,
      payload,
      provider_token,
      currency,
      prices,
      ...other
    }, signal);
  }
  createInvoiceLink(title2, description, payload, provider_token, currency, prices, other, signal) {
    return this.raw.createInvoiceLink({
      title: title2,
      description,
      payload,
      provider_token,
      currency,
      prices,
      ...other
    }, signal);
  }
  answerShippingQuery(shipping_query_id, ok2, other, signal) {
    return this.raw.answerShippingQuery({
      shipping_query_id,
      ok: ok2,
      ...other
    }, signal);
  }
  answerPreCheckoutQuery(pre_checkout_query_id, ok2, other, signal) {
    return this.raw.answerPreCheckoutQuery({
      pre_checkout_query_id,
      ok: ok2,
      ...other
    }, signal);
  }
  setPassportDataErrors(user_id, errors, signal) {
    return this.raw.setPassportDataErrors({
      user_id,
      errors
    }, signal);
  }
  sendGame(chat_id, game_short_name, other, signal) {
    return this.raw.sendGame({
      chat_id,
      game_short_name,
      ...other
    }, signal);
  }
  setGameScore(chat_id, message_id, user_id, score, other, signal) {
    return this.raw.setGameScore({
      chat_id,
      message_id,
      user_id,
      score,
      ...other
    }, signal);
  }
  setGameScoreInline(inline_message_id, user_id, score, other, signal) {
    return this.raw.setGameScore({
      inline_message_id,
      user_id,
      score,
      ...other
    }, signal);
  }
  getGameHighScores(chat_id, message_id, user_id, signal) {
    return this.raw.getGameHighScores({
      chat_id,
      message_id,
      user_id
    }, signal);
  }
  getGameHighScoresInline(inline_message_id, user_id, signal) {
    return this.raw.getGameHighScores({
      inline_message_id,
      user_id
    }, signal);
  }
};
var debug1 = browser$1("grammy:bot");
var debugWarn = browser$1("grammy:warn");
var debugErr = browser$1("grammy:error");
var DEFAULT_UPDATE_TYPES = [
  "message",
  "edited_message",
  "channel_post",
  "edited_channel_post",
  "inline_query",
  "chosen_inline_result",
  "callback_query",
  "shipping_query",
  "pre_checkout_query",
  "poll",
  "poll_answer",
  "my_chat_member",
  "chat_join_request",
  "chat_boost",
  "removed_chat_boost"
];
var Bot = class extends Composer {
  constructor(token, config2) {
    var _a;
    super();
    __publicField(this, "token");
    __publicField(this, "pollingRunning");
    __publicField(this, "pollingAbortController");
    __publicField(this, "lastTriedUpdateId");
    __publicField(this, "api");
    __publicField(this, "me");
    __publicField(this, "mePromise");
    __publicField(this, "clientConfig");
    __publicField(this, "ContextConstructor");
    __publicField(this, "observedUpdateTypes");
    __publicField(this, "errorHandler");
    this.token = token;
    this.pollingRunning = false;
    this.lastTriedUpdateId = 0;
    this.observedUpdateTypes = /* @__PURE__ */ new Set();
    this.errorHandler = async (err) => {
      var _a2, _b;
      console.error("Error in middleware while handling update", (_b = (_a2 = err.ctx) == null ? void 0 : _a2.update) == null ? void 0 : _b.update_id, err.error);
      console.error("No error handler was set!");
      console.error("Set your own error handler with `bot.catch = ...`");
      if (this.pollingRunning) {
        console.error("Stopping bot");
        await this.stop();
      }
      throw err;
    };
    if (!token)
      throw new Error("Empty token!");
    this.me = config2 == null ? void 0 : config2.botInfo;
    this.clientConfig = config2 == null ? void 0 : config2.client;
    this.ContextConstructor = (_a = config2 == null ? void 0 : config2.ContextConstructor) != null ? _a : Context;
    this.api = new Api(token, this.clientConfig);
  }
  set botInfo(botInfo) {
    this.me = botInfo;
  }
  get botInfo() {
    if (this.me === void 0) {
      throw new Error("Bot information unavailable! Make sure to call `await bot.init()` before accessing `bot.botInfo`!");
    }
    return this.me;
  }
  on(filter, ...middleware) {
    for (const [u] of parse(filter).flatMap(preprocess)) {
      this.observedUpdateTypes.add(u);
    }
    return super.on(filter, ...middleware);
  }
  reaction(reaction, ...middleware) {
    this.observedUpdateTypes.add("message_reaction");
    return super.reaction(reaction, ...middleware);
  }
  isInited() {
    return this.me !== void 0;
  }
  async init(signal) {
    var _a;
    if (!this.isInited()) {
      debug1("Initializing bot");
      (_a = this.mePromise) != null ? _a : this.mePromise = withRetries(() => this.api.getMe(signal), signal);
      let me;
      try {
        me = await this.mePromise;
      } finally {
        this.mePromise = void 0;
      }
      if (this.me === void 0)
        this.me = me;
      else
        debug1("Bot info was set by now, will not overwrite");
    }
    debug1(`I am ${this.me.username}!`);
  }
  async handleUpdates(updates) {
    for (const update of updates) {
      this.lastTriedUpdateId = update.update_id;
      try {
        await this.handleUpdate(update);
      } catch (err) {
        if (err instanceof BotError) {
          await this.errorHandler(err);
        } else {
          console.error("FATAL: grammY unable to handle:", err);
          throw err;
        }
      }
    }
  }
  async handleUpdate(update, webhookReplyEnvelope) {
    if (this.me === void 0) {
      throw new Error("Bot not initialized! Either call `await bot.init()`, or directly set the `botInfo` option in the `Bot` constructor to specify a known bot info object.");
    }
    debug1(`Processing update ${update.update_id}`);
    const api = new Api(this.token, this.clientConfig, webhookReplyEnvelope);
    const t = this.api.config.installedTransformers();
    if (t.length > 0)
      api.config.use(...t);
    const ctx = new this.ContextConstructor(update, api, this.me);
    try {
      await run(this.middleware(), ctx);
    } catch (err) {
      debugErr(`Error in middleware for update ${update.update_id}`);
      throw new BotError(err, ctx);
    }
  }
  async start(options) {
    var _a, _b, _c;
    const setup2 = [];
    if (!this.isInited()) {
      setup2.push(this.init((_a = this.pollingAbortController) == null ? void 0 : _a.signal));
    }
    if (this.pollingRunning) {
      await Promise.all(setup2);
      debug1("Simple long polling already running!");
      return;
    } else {
      this.pollingRunning = true;
      this.pollingAbortController = new AbortController();
    }
    setup2.push(withRetries(async () => {
      var _a2;
      await this.api.deleteWebhook({
        drop_pending_updates: options == null ? void 0 : options.drop_pending_updates
      }, (_a2 = this.pollingAbortController) == null ? void 0 : _a2.signal);
    }, (_b = this.pollingAbortController) == null ? void 0 : _b.signal));
    await Promise.all(setup2);
    await ((_c = options == null ? void 0 : options.onStart) == null ? void 0 : _c.call(options, this.botInfo));
    if (!this.pollingRunning)
      return;
    validateAllowedUpdates(this.observedUpdateTypes, options == null ? void 0 : options.allowed_updates);
    this.use = noUseFunction;
    debug1("Starting simple long polling");
    await this.loop(options);
    debug1("Middleware is done running");
  }
  async stop() {
    var _a;
    if (this.pollingRunning) {
      debug1("Stopping bot, saving update offset");
      this.pollingRunning = false;
      (_a = this.pollingAbortController) == null ? void 0 : _a.abort();
      const offset = this.lastTriedUpdateId + 1;
      await this.api.getUpdates({
        offset,
        limit: 1
      }).finally(() => this.pollingAbortController = void 0);
    } else {
      debug1("Bot is not running!");
    }
  }
  catch(errorHandler) {
    this.errorHandler = errorHandler;
  }
  async loop(options) {
    var _a, _b;
    const limit = options == null ? void 0 : options.limit;
    const timeout = (_a = options == null ? void 0 : options.timeout) != null ? _a : 30;
    let allowed_updates = (_b = options == null ? void 0 : options.allowed_updates) != null ? _b : [];
    while (this.pollingRunning) {
      const updates = await this.fetchUpdates({
        limit,
        timeout,
        allowed_updates
      });
      if (updates === void 0)
        break;
      await this.handleUpdates(updates);
      allowed_updates = void 0;
    }
  }
  async fetchUpdates({ limit, timeout, allowed_updates }) {
    var _a;
    const offset = this.lastTriedUpdateId + 1;
    let updates = void 0;
    do {
      try {
        updates = await this.api.getUpdates({
          offset,
          limit,
          timeout,
          allowed_updates
        }, (_a = this.pollingAbortController) == null ? void 0 : _a.signal);
      } catch (error) {
        await this.handlePollingError(error);
      }
    } while (updates === void 0 && this.pollingRunning);
    return updates;
  }
  async handlePollingError(error) {
    var _a;
    if (!this.pollingRunning) {
      debug1("Pending getUpdates request cancelled");
      return;
    }
    let sleepSeconds = 3;
    if (error instanceof GrammyError) {
      debugErr(error.message);
      if (error.error_code === 401) {
        debugErr("Make sure you are using the bot token you obtained from @BotFather (https://t.me/BotFather).");
        throw error;
      } else if (error.error_code === 409) {
        debugErr("Consider revoking the bot token if you believe that no other instance is running.");
        throw error;
      } else if (error.error_code === 429) {
        debugErr("Bot API server is closing.");
        sleepSeconds = (_a = error.parameters.retry_after) != null ? _a : sleepSeconds;
      }
    } else
      debugErr(error);
    debugErr(`Call to getUpdates failed, retrying in ${sleepSeconds} seconds ...`);
    await sleep(sleepSeconds);
  }
};
async function withRetries(task, signal) {
  const INITIAL_DELAY = 50;
  let lastDelay = 50;
  async function handleError(error) {
    let delay = false;
    let strategy = "rethrow";
    if (error instanceof HttpError) {
      delay = true;
      strategy = "retry";
    } else if (error instanceof GrammyError) {
      if (error.error_code >= 500) {
        delay = true;
        strategy = "retry";
      } else if (error.error_code === 429) {
        const retryAfter = error.parameters.retry_after;
        if (typeof retryAfter === "number") {
          await sleep(retryAfter, signal);
          lastDelay = INITIAL_DELAY;
        } else {
          delay = true;
        }
        strategy = "retry";
      }
    }
    if (delay) {
      if (lastDelay !== 50) {
        await sleep(lastDelay, signal);
      }
      const TWENTY_MINUTES = 20 * 60 * 1e3;
      lastDelay = Math.min(TWENTY_MINUTES, 2 * lastDelay);
    }
    return strategy;
  }
  let result = {
    ok: false
  };
  while (!result.ok) {
    try {
      result = {
        ok: true,
        value: await task()
      };
    } catch (error) {
      debugErr(error);
      const strategy = await handleError(error);
      switch (strategy) {
        case "retry":
          continue;
        case "rethrow":
          throw error;
      }
    }
  }
  return result.value;
}
async function sleep(seconds, signal) {
  let handle;
  let reject;
  function abort() {
    reject == null ? void 0 : reject(new Error("Aborted delay"));
    if (handle !== void 0)
      clearTimeout(handle);
  }
  try {
    await new Promise((res, rej) => {
      reject = rej;
      if (signal == null ? void 0 : signal.aborted) {
        abort();
        return;
      }
      signal == null ? void 0 : signal.addEventListener("abort", abort);
      handle = setTimeout(res, 1e3 * seconds);
    });
  } finally {
    signal == null ? void 0 : signal.removeEventListener("abort", abort);
  }
}
function validateAllowedUpdates(updates, allowed = DEFAULT_UPDATE_TYPES) {
  const impossible = Array.from(updates).filter((u) => !allowed.includes(u));
  if (impossible.length > 0) {
    debugWarn(`You registered listeners for the following update types, but you did not specify them in \`allowed_updates\` so they may not be received: ${impossible.map((u) => `'${u}'`).join(", ")}`);
  }
}
function noUseFunction() {
  throw new Error(`It looks like you are registering more listeners on your bot from within other listeners! This means that every time your bot handles a message like this one, new listeners will be added. This list grows until your machine crashes, so grammY throws this error to tell you that you should probably do things a bit differently. If you're unsure how to resolve this problem, you can ask in the group chat: https://telegram.me/grammyjs

On the other hand, if you actually know what you're doing and you do need to install further middleware while your bot is running, consider installing a composer instance on your bot, and in turn augment the composer after the fact. This way, you can circumvent this protection against memory leaks.`);
}
var ALL_UPDATE_TYPES = [
  ...DEFAULT_UPDATE_TYPES,
  "chat_member",
  "message_reaction",
  "message_reaction_count"
];
var ALL_CHAT_PERMISSIONS = {
  can_send_messages: true,
  can_send_audios: true,
  can_send_documents: true,
  can_send_photos: true,
  can_send_videos: true,
  can_send_video_notes: true,
  can_send_voice_notes: true,
  can_send_polls: true,
  can_send_other_messages: true,
  can_add_web_page_previews: true,
  can_change_info: true,
  can_invite_users: true,
  can_pin_messages: true,
  can_manage_topics: true
};
var API_CONSTANTS = {
  DEFAULT_UPDATE_TYPES,
  ALL_UPDATE_TYPES,
  ALL_CHAT_PERMISSIONS
};
Object.freeze(API_CONSTANTS);
var debug2 = browser$1("grammy:session");
var SECRET_HEADER = "X-Telegram-Bot-Api-Secret-Token";
var SECRET_HEADER_LOWERCASE = SECRET_HEADER.toLowerCase();
var WRONG_TOKEN_ERROR = "secret token is wrong";
var ok = () => new Response(null, {
  status: 200
});
var okJson = (json) => new Response(json, {
  status: 200,
  headers: {
    "Content-Type": "application/json"
  }
});
var unauthorized = () => new Response('"unauthorized"', {
  status: 401,
  statusText: WRONG_TOKEN_ERROR
});
var awsLambda = (event, _context, callback) => ({
  update: JSON.parse(event.body),
  header: event.headers[SECRET_HEADER],
  end: () => callback(null, {
    statusCode: 200
  }),
  respond: (json) => callback(null, {
    statusCode: 200,
    headers: {
      "Content-Type": "application/json"
    },
    body: json
  }),
  unauthorized: () => callback(null, {
    statusCode: 401
  })
});
var awsLambdaAsync = (event, _context) => {
  let resolveResponse;
  return {
    update: JSON.parse(event.body),
    header: event.headers[SECRET_HEADER],
    end: () => resolveResponse({
      statusCode: 200
    }),
    respond: (json) => resolveResponse({
      statusCode: 200,
      headers: {
        "Content-Type": "application/json"
      },
      body: json
    }),
    unauthorized: () => resolveResponse({
      statusCode: 401
    }),
    handlerReturn: new Promise((resolve) => {
      resolveResponse = resolve;
    })
  };
};
var azure = (context, req) => ({
  update: Promise.resolve(req.body),
  header: context.res.headers[SECRET_HEADER],
  end: () => context.res = {
    status: 200,
    body: ""
  },
  respond: (json) => {
    context.res.set("Content-Type", "application/json");
    context.res.send(json);
  },
  unauthorized: () => {
    context.res.send(401, WRONG_TOKEN_ERROR);
  }
});
var cloudflare = (event) => {
  let resolveResponse;
  event.respondWith(new Promise((resolve) => {
    resolveResponse = resolve;
  }));
  return {
    update: event.request.json(),
    header: event.request.headers.get(SECRET_HEADER) || void 0,
    end: () => {
      resolveResponse(ok());
    },
    respond: (json) => {
      resolveResponse(okJson(json));
    },
    unauthorized: () => {
      resolveResponse(unauthorized());
    }
  };
};
var cloudflareModule = (request) => {
  let resolveResponse;
  return {
    update: request.json(),
    header: request.headers.get(SECRET_HEADER) || void 0,
    end: () => {
      resolveResponse(ok());
    },
    respond: (json) => {
      resolveResponse(okJson(json));
    },
    unauthorized: () => {
      resolveResponse(unauthorized());
    },
    handlerReturn: new Promise((resolve) => {
      resolveResponse = resolve;
    })
  };
};
var express = (req, res) => ({
  update: Promise.resolve(req.body),
  header: req.header(SECRET_HEADER),
  end: () => res.end(),
  respond: (json) => {
    res.set("Content-Type", "application/json");
    res.send(json);
  },
  unauthorized: () => {
    res.status(401).send(WRONG_TOKEN_ERROR);
  }
});
var fastify = (req, reply) => ({
  update: Promise.resolve(req.body),
  header: req.headers[SECRET_HEADER_LOWERCASE],
  end: () => reply.status(200).send(),
  respond: (json) => reply.send(json),
  unauthorized: () => reply.code(401).send(WRONG_TOKEN_ERROR)
});
var hono = (ctx) => {
  let resolveResponse;
  return {
    update: ctx.req.json(),
    header: ctx.req.header(SECRET_HEADER),
    end: () => {
      resolveResponse(ctx.body());
    },
    respond: (json) => {
      resolveResponse(ctx.json(json));
    },
    unauthorized: () => {
      ctx.status(401);
      ctx.statusText(WRONG_TOKEN_ERROR);
      resolveResponse(ctx.body());
    },
    handlerReturn: new Promise((resolve) => {
      resolveResponse = resolve;
    })
  };
};
var http = (req, res) => {
  const secretHeaderFromRequest = req.headers[SECRET_HEADER_LOWERCASE];
  return {
    update: new Promise((resolve, reject) => {
      const chunks = [];
      req.on("data", (chunk) => chunks.push(chunk)).once("end", () => {
        const raw = Buffer.concat(chunks).toString("utf-8");
        resolve(JSON.parse(raw));
      }).once("error", reject);
    }),
    header: Array.isArray(secretHeaderFromRequest) ? secretHeaderFromRequest[0] : secretHeaderFromRequest,
    end: () => res.end(),
    respond: (json) => res.writeHead(200, {
      "Content-Type": "application/json"
    }).end(json),
    unauthorized: () => res.writeHead(401).end(WRONG_TOKEN_ERROR)
  };
};
var koa = (ctx) => ({
  update: Promise.resolve(ctx.request.body),
  header: ctx.get(SECRET_HEADER),
  end: () => {
    ctx.body = "";
  },
  respond: (json) => {
    ctx.set("Content-Type", "application/json");
    ctx.response.body = json;
  },
  unauthorized: () => {
    ctx.status = 401;
  }
});
var nextJs = (req, res) => ({
  update: Promise.resolve(req.body),
  header: req.headers[SECRET_HEADER_LOWERCASE],
  end: () => res.end(),
  respond: (json) => res.status(200).json(json),
  unauthorized: () => res.status(401).send(WRONG_TOKEN_ERROR)
});
var nhttp = (rev) => ({
  update: rev.body,
  header: rev.headers.get(SECRET_HEADER) || void 0,
  end: () => rev.response.sendStatus(200),
  respond: (json) => rev.response.status(200).send(json),
  unauthorized: () => rev.response.status(401).send(WRONG_TOKEN_ERROR)
});
var oak = (ctx) => ({
  update: ctx.request.body({
    type: "json"
  }).value,
  header: ctx.request.headers.get(SECRET_HEADER) || void 0,
  end: () => {
    ctx.response.status = 200;
  },
  respond: (json) => {
    ctx.response.type = "json";
    ctx.response.body = json;
  },
  unauthorized: () => {
    ctx.response.status = 401;
  }
});
var serveHttp = (requestEvent) => ({
  update: requestEvent.request.json(),
  header: requestEvent.request.headers.get(SECRET_HEADER) || void 0,
  end: () => requestEvent.respondWith(ok()),
  respond: (json) => requestEvent.respondWith(okJson(json)),
  unauthorized: () => requestEvent.respondWith(unauthorized())
});
var stdHttp = (req) => {
  let resolveResponse;
  return {
    update: req.json(),
    header: req.headers.get(SECRET_HEADER) || void 0,
    end: () => {
      if (resolveResponse)
        resolveResponse(ok());
    },
    respond: (json) => {
      if (resolveResponse)
        resolveResponse(okJson(json));
    },
    unauthorized: () => {
      if (resolveResponse)
        resolveResponse(unauthorized());
    },
    handlerReturn: new Promise((resolve) => {
      resolveResponse = resolve;
    })
  };
};
var sveltekit = ({ request }) => {
  let resolveResponse;
  return {
    update: Promise.resolve(request.json()),
    header: request.headers.get(SECRET_HEADER) || void 0,
    end: () => {
      if (resolveResponse)
        resolveResponse(ok());
    },
    respond: (json) => {
      if (resolveResponse)
        resolveResponse(okJson(json));
    },
    unauthorized: () => {
      if (resolveResponse)
        resolveResponse(unauthorized());
    },
    handlerReturn: new Promise((resolve) => {
      resolveResponse = resolve;
    })
  };
};
var worktop = (req, res) => ({
  update: Promise.resolve(req.body.json()),
  header: req.headers.get(SECRET_HEADER),
  end: () => res.end(),
  respond: (json) => res.send(200, json),
  unauthorized: () => res.send(401, WRONG_TOKEN_ERROR)
});
var adapters = {
  "aws-lambda": awsLambda,
  "aws-lambda-async": awsLambdaAsync,
  azure,
  cloudflare,
  "cloudflare-mod": cloudflareModule,
  express,
  fastify,
  hono,
  http,
  https: http,
  koa,
  "next-js": nextJs,
  nhttp,
  oak,
  serveHttp,
  "std/http": stdHttp,
  sveltekit,
  worktop
};
var debugErr1 = browser$1("grammy:error");
var callbackAdapter = (update, callback, header, unauthorized2 = () => callback('"unauthorized"')) => ({
  update: Promise.resolve(update),
  respond: callback,
  header,
  unauthorized: unauthorized2
});
var adapters1 = {
  ...adapters,
  callback: callbackAdapter
};

// src/bot.ts
var import_obsidian5 = require("obsidian");

// src/utils/diary.ts
var import_obsidian = require("obsidian");
var import_obsidian_daily_notes_interface = __toESM(require_main());
async function createDiary() {
  const date = (0, import_obsidian.moment)();
  return await (0, import_obsidian_daily_notes_interface.createDailyNote)(date);
}
async function getTodayDiary() {
  try {
    const date = (0, import_obsidian.moment)();
    const dailyNotes = (0, import_obsidian_daily_notes_interface.getAllDailyNotes)();
    let dailyNote = (0, import_obsidian_daily_notes_interface.getDailyNote)(date, dailyNotes);
    if (!dailyNote) {
      console.log("Daily note not found, creating new one");
      dailyNote = await createDiary();
    }
    return dailyNote;
  } catch (error) {
    console.error(`Error retrieving or creating today's diary: ${error}`);
    throw error;
  }
}

// src/io.ts
async function insertMessage(vault, message, tFile) {
  try {
    await vault.process(tFile, (data) => {
      const updatedContent = data.trim() === "" ? message : data.endsWith("\n") ? `${data}${message}` : `${data}
${message}`;
      return updatedContent;
    });
  } catch (error) {
    throw new Error(`Error inserting message. ${error}`);
  }
}
async function insertMessageAtTop(vault, message, tFile) {
  try {
    await vault.process(tFile, (data) => {
      const updatedContent = `${message}
${data}`;
      return updatedContent;
    });
  } catch (error) {
    throw new Error(`Error inserting message. ${error}`);
  }
}

// src/utils/download.ts
var import_obsidian2 = require("obsidian");
function downloadAsArrayBuffer(url) {
  return (0, import_obsidian2.requestUrl)(url).arrayBuffer;
}
async function downloadAndSaveFile(url, filename_ext, download_dir) {
  try {
    const fileArrayBuffer = await downloadAsArrayBuffer(url);
    this.app.vault.createBinary(
      (0, import_obsidian2.normalizePath)(`${download_dir}/${filename_ext}`),
      fileArrayBuffer
    );
    return true;
  } catch (error) {
    console.error("Error downloading file:", error);
    return false;
  }
}

// src/utils/markdown.ts
var import_entity = __toESM(require_mod());
var markdownSerialiser = (match2, node) => {
  switch (node == null ? void 0 : node.type) {
    case "bold":
      return `**${match2}**`;
    case "italic":
      return `*${match2}*`;
    case "underline":
      return `<u>${match2}</u>`;
    case "strikethrough":
      return `~~${match2}~~`;
    case "code":
      return `\`${match2}\``;
    case "pre":
      if (node.language)
        return "```" + node.language + "\n" + match2 + "\n```";
      return "```\n" + match2 + "\n```";
    case "spoiler":
      return `==${match2}==`;
    case "url":
      return match2;
    case "text_link":
      return `[${match2}](${node.url})`;
    case "text_mention":
      return `[${match2}](tg://user?id=${node.user.id})`;
    case "blockquote":
      return `${match2.split("\n").map((line) => `>${line}`).join("\n")}`;
    case "mention":
    case "custom_emoji":
    case "hashtag":
    case "cashtag":
    case "bot_command":
    case "phone_number":
    case "email":
    default:
      return match2;
  }
};
function toMarkdownV2(msg, settings) {
  const selectedEscaper = settings.markdown_escaper ? import_entity.escapers.MarkdownV2 : import_entity.escapers.HTML;
  return (0, import_entity.serialiseWith)(markdownSerialiser, selectedEscaper)(msg);
}

// src/utils/template.ts
var import_obsidian3 = require("obsidian");
var Mustache = __toESM(require_mustache());
function generateContentFromTemplate(msg, setting) {
  const data = buildMsgData(msg, setting);
  return Mustache.render(setting.message_template, data);
}
function buildMsgData(msg, setting) {
  var _a, _b;
  const forwardOrigin = getForwardOrigin(msg);
  const data = {
    message_id: msg.message_id,
    text: toMarkdownV2(msg, setting),
    date: (0, import_obsidian3.moment)(msg.date * 1e3).format("YYYY-MM-DD"),
    time: (0, import_obsidian3.moment)(msg.date * 1e3).format("HH:mm"),
    name: getSenderName(msg),
    username: (_a = msg.from) == null ? void 0 : _a.username,
    user_id: ((_b = msg.from) == null ? void 0 : _b.id) || 0,
    ...forwardOrigin
  };
  return data;
}
function generatePath(msg, setting) {
  const data = rereplaceSpecialChar(buildPathData(msg));
  const path = Mustache.render(setting.custom_file_path, data);
  return path;
}
function rereplaceSpecialChar(data) {
  const regex = /[/\\[\]#^|:?*"<>]/g;
  data.first_name = data.first_name.replace(regex, "~");
  data.name = data.name.replace(regex, "~");
  data.origin_name = data.origin_name.replace(regex, "~");
  return data;
}
function buildPathData(msg) {
  var _a, _b;
  const data = {
    date: (0, import_obsidian3.moment)(msg.date * 1e3).format("YYYY-MM-DD"),
    first_name: msg.from.first_name,
    name: getSenderName(msg),
    time: (0, import_obsidian3.moment)(msg.date * 1e3).format("HH-mm"),
    user_id: ((_a = msg.from) == null ? void 0 : _a.id) || 0,
    origin_name: ((_b = getForwardOrigin(msg)) == null ? void 0 : _b.origin_name) || getSenderName(msg)
  };
  return data;
}
function getForwardOrigin(msg) {
  if (!msg.forward_origin) {
    return null;
  }
  const { type } = msg.forward_origin;
  switch (type) {
    case "user":
      return {
        origin_name: getUserName(msg.forward_origin.sender_user),
        origin_username: msg.forward_origin.sender_user.username || ""
      };
    case "hidden_user":
      return {
        origin_name: msg.forward_origin.sender_user_name,
        origin_username: ""
      };
    case "channel": {
      const chat = msg.forward_origin.chat;
      return {
        origin_name: chat.title,
        origin_username: chat.username || "",
        origin_link: `https://t.me/${chat.username ? chat.username : chat.id}/${msg.forward_origin.message_id}`
      };
    }
    case "chat": {
      const chat = msg.forward_origin.sender_chat;
      if (chat.type === "private") {
        return {
          origin_name: chat.first_name + chat.last_name ? ` ${chat.last_name}` : "",
          origin_username: ""
        };
      }
      if (chat.type === "group") {
        return {
          origin_name: chat.title,
          origin_username: ""
        };
      }
      break;
    }
  }
}
function getUserName(user) {
  return `${user.first_name}${user.last_name ? ` ${user.last_name}` : ""}`;
}
function getSenderName(msg) {
  var _a;
  return `${msg.from.first_name}${((_a = msg.from) == null ? void 0 : _a.last_name) ? ` ${msg.from.last_name}` : ""}`;
}

// src/utils/file.ts
var import_obsidian4 = require("obsidian");
function getExt2(path) {
  return path.split(".").pop();
}
function getFileUrl(file, token) {
  const TG_API = "https://api.telegram.org/file/bot";
  return `${TG_API}${token}/${file.file_path}`;
}
async function getSavePath(vault, settings, msg) {
  try {
    if (settings.is_custom_file && msg && settings.custom_file_path) {
      let normalizedPath = settings.custom_file_path ? (0, import_obsidian4.normalizePath)(generatePath(msg, settings)) : (0, import_obsidian4.normalizePath)("Telegram-Inbox.md");
      if (!normalizedPath.endsWith(".md")) {
        normalizedPath += ".md";
      }
      const file = vault.getFileByPath(normalizedPath);
      if (!file) {
        console.debug(`File not found. Creating new file at: ${normalizedPath}`);
        return await createTargetFile(vault, normalizedPath);
      }
      return file;
    }
    return getTodayDiary();
  } catch (error) {
    console.error(`Error in getSavedPath: ${error}`);
    throw error;
  }
}
async function createTargetFile(vault, filePath) {
  try {
    console.debug(`Creating target file: ${filePath}`);
    const dirPath = getDirPath(filePath);
    if (dirPath) {
      console.debug(`Directory path extracted: ${dirPath}`);
      await ensureDirExists(vault, dirPath);
    }
    const file = await vault.create(filePath, "");
    console.log(`File created: ${filePath}`);
    return file;
  } catch (error) {
    console.error(`Error creating target file: ${error}`);
    throw error;
  }
}
async function ensureDirExists(vault, dirPath) {
  try {
    const dir = vault.getAbstractFileByPath(dirPath);
    if (!dir) {
      await vault.createFolder(dirPath);
      console.log(`Folder created: ${dirPath}`);
    } else {
      console.log(`Folder already exists: ${dirPath}`);
    }
  } catch (error) {
    console.error(`Error ensuring directory exists: ${error}`);
    throw error;
  }
}
function getDirPath(filePath) {
  const lastSlashIndex = filePath.lastIndexOf("/");
  if (lastSlashIndex === -1)
    return "";
  return filePath.substring(0, lastSlashIndex);
}

// node_modules/.pnpm/async-mutex@0.5.0/node_modules/async-mutex/index.mjs
var E_TIMEOUT = new Error("timeout while waiting for mutex to become available");
var E_ALREADY_LOCKED = new Error("mutex already locked");
var E_CANCELED = new Error("request for lock canceled");
var __awaiter$2 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var Semaphore = class {
  constructor(_value, _cancelError = E_CANCELED) {
    this._value = _value;
    this._cancelError = _cancelError;
    this._queue = [];
    this._weightedWaiters = [];
  }
  acquire(weight = 1, priority = 0) {
    if (weight <= 0)
      throw new Error(`invalid weight ${weight}: must be positive`);
    return new Promise((resolve, reject) => {
      const task = { resolve, reject, weight, priority };
      const i = findIndexFromEnd(this._queue, (other) => priority <= other.priority);
      if (i === -1 && weight <= this._value) {
        this._dispatchItem(task);
      } else {
        this._queue.splice(i + 1, 0, task);
      }
    });
  }
  runExclusive(callback_1) {
    return __awaiter$2(this, arguments, void 0, function* (callback, weight = 1, priority = 0) {
      const [value, release2] = yield this.acquire(weight, priority);
      try {
        return yield callback(value);
      } finally {
        release2();
      }
    });
  }
  waitForUnlock(weight = 1, priority = 0) {
    if (weight <= 0)
      throw new Error(`invalid weight ${weight}: must be positive`);
    if (this._couldLockImmediately(weight, priority)) {
      return Promise.resolve();
    } else {
      return new Promise((resolve) => {
        if (!this._weightedWaiters[weight - 1])
          this._weightedWaiters[weight - 1] = [];
        insertSorted(this._weightedWaiters[weight - 1], { resolve, priority });
      });
    }
  }
  isLocked() {
    return this._value <= 0;
  }
  getValue() {
    return this._value;
  }
  setValue(value) {
    this._value = value;
    this._dispatchQueue();
  }
  release(weight = 1) {
    if (weight <= 0)
      throw new Error(`invalid weight ${weight}: must be positive`);
    this._value += weight;
    this._dispatchQueue();
  }
  cancel() {
    this._queue.forEach((entry) => entry.reject(this._cancelError));
    this._queue = [];
  }
  _dispatchQueue() {
    this._drainUnlockWaiters();
    while (this._queue.length > 0 && this._queue[0].weight <= this._value) {
      this._dispatchItem(this._queue.shift());
      this._drainUnlockWaiters();
    }
  }
  _dispatchItem(item) {
    const previousValue = this._value;
    this._value -= item.weight;
    item.resolve([previousValue, this._newReleaser(item.weight)]);
  }
  _newReleaser(weight) {
    let called = false;
    return () => {
      if (called)
        return;
      called = true;
      this.release(weight);
    };
  }
  _drainUnlockWaiters() {
    if (this._queue.length === 0) {
      for (let weight = this._value; weight > 0; weight--) {
        const waiters = this._weightedWaiters[weight - 1];
        if (!waiters)
          continue;
        waiters.forEach((waiter) => waiter.resolve());
        this._weightedWaiters[weight - 1] = [];
      }
    } else {
      const queuedPriority = this._queue[0].priority;
      for (let weight = this._value; weight > 0; weight--) {
        const waiters = this._weightedWaiters[weight - 1];
        if (!waiters)
          continue;
        const i = waiters.findIndex((waiter) => waiter.priority <= queuedPriority);
        (i === -1 ? waiters : waiters.splice(0, i)).forEach((waiter) => waiter.resolve());
      }
    }
  }
  _couldLockImmediately(weight, priority) {
    return (this._queue.length === 0 || this._queue[0].priority < priority) && weight <= this._value;
  }
};
function insertSorted(a, v) {
  const i = findIndexFromEnd(a, (other) => v.priority <= other.priority);
  a.splice(i + 1, 0, v);
}
function findIndexFromEnd(a, predicate) {
  for (let i = a.length - 1; i >= 0; i--) {
    if (predicate(a[i])) {
      return i;
    }
  }
  return -1;
}
var __awaiter$1 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var Mutex = class {
  constructor(cancelError) {
    this._semaphore = new Semaphore(1, cancelError);
  }
  acquire() {
    return __awaiter$1(this, arguments, void 0, function* (priority = 0) {
      const [, releaser] = yield this._semaphore.acquire(1, priority);
      return releaser;
    });
  }
  runExclusive(callback, priority = 0) {
    return this._semaphore.runExclusive(() => callback(), 1, priority);
  }
  isLocked() {
    return this._semaphore.isLocked();
  }
  waitForUnlock(priority = 0) {
    return this._semaphore.waitForUnlock(1, priority);
  }
  release() {
    if (this._semaphore.isLocked())
      this._semaphore.release();
  }
  cancel() {
    return this._semaphore.cancel();
  }
};

// src/bot.ts
var TelegramBot = class {
  constructor(vault, settings) {
    this.mutex = new Mutex();
    const restrictToAllowedUsers = this.createRestrictToAllowedUsersMiddleware(settings);
    const recordUpdateId = this.createRecordUpdateIdMiddleware();
    this.bot = new Bot(settings.token);
    if (settings.disable_auto_reception) {
      this.bot.init();
    }
    this.bot.use(restrictToAllowedUsers);
    this.bot.use(recordUpdateId);
    this.vault = vault;
    this.settings = settings;
    this.setupCommands();
    this.setupMessageHandlers(settings);
    this.bot.catch((err) => {
      console.error("An error occurred in the Telegram bot:", err);
    });
  }
  start() {
    this.bot.start();
  }
  async getUpdates() {
    const offset = this.update_id ? this.update_id + 1 : 1;
    const updates = await this.bot.api.getUpdates({ offset });
    updates.map(async (update) => await this.bot.handleUpdate(update));
    if (updates.length > 0) {
      this.bot.api.getUpdates({ offset: this.update_id + 1, limit: 1 });
    }
  }
  createRestrictToAllowedUsersMiddleware(settings) {
    return new Composer().use(async (ctx, next) => {
      var _a, _b;
      const userId = (_a = ctx.from) == null ? void 0 : _a.id;
      const username = (_b = ctx.from) == null ? void 0 : _b.username;
      if (username && settings.allow_users.includes(username) || userId && settings.allow_users.includes(userId.toString())) {
        await next();
      } else {
        console.log(`Unauthorized access attempt: User ${username || userId} tried to access the bot at ${new Date().toISOString()}`);
      }
    });
  }
  createRecordUpdateIdMiddleware() {
    return new Composer().use(async (ctx, next) => {
      var _a;
      const updateId = (_a = ctx.update) == null ? void 0 : _a.update_id;
      if (updateId) {
        this.update_id = updateId;
      }
      await next();
    });
  }
  setupCommands() {
    this.bot.command("start", (ctx) => {
      ctx.reply(
        "Hello! Send me a message to add it to your Obsidian daily note.\n\n/task followed by the description will add it as a task item."
      );
    });
    this.bot.command("task", async (ctx) => {
      const task = `- [ ] ${ctx.match}`;
      this.insertMessageToVault(task);
      ctx.react("\u2764");
    });
  }
  setupMessageHandlers(settings) {
    this.bot.on("message:text", async (ctx) => {
      var _a, _b;
      console.debug(`Received text message [${ctx.message.message_id}] from user ${((_a = ctx.from) == null ? void 0 : _a.username) || ((_b = ctx.from) == null ? void 0 : _b.id)}`);
      const content = generateContentFromTemplate(ctx.msg, settings);
      await this.insertMessageToVault(content, { msg: ctx.message }).then((_) => ctx.react("\u2764")).catch((err) => {
        console.error(`Failed to insert text message to vault. Error: ${err.message}`, err);
        ctx.reply(`Failed to insert text message to vault. Error: ${err.message}`, err);
      });
    });
    this.bot.on("message:media", async (ctx) => {
      var _a, _b;
      console.debug(`Received media message [${ctx.message.message_id}] from user ${((_a = ctx.from) == null ? void 0 : _a.username) || ((_b = ctx.from) == null ? void 0 : _b.id)}`);
      let content = generateContentFromTemplate(ctx.message, settings);
      if (settings.download_media) {
        const file = await ctx.getFile();
        const filename_ext = this.generateFilename(ctx.message, file);
        const url = getFileUrl(file, this.bot.token);
        console.debug(`Attempting to download media: ${filename_ext} from ${url}`);
        const downloadResult = await downloadAndSaveFile(url, filename_ext, settings.download_dir);
        if (downloadResult) {
          content = `![[${filename_ext}]]
${content}`;
        } else {
          console.error(`Failed to download media. File: ${filename_ext}, URL: ${url}`);
          ctx.reply(`Failed to download media. File: ${filename_ext}, URL: ${url}`);
        }
      }
      await this.insertMessageToVault(content, { msg: ctx.message }).then((_) => ctx.react("\u2764")).catch((err) => {
        console.error(`Failed to insert media message to vault. Error: ${err.message}`, err);
        ctx.reply(`Failed to insert media message to vault. Error: ${err.message}`, err);
      });
    });
  }
  generateFilename(msg, file) {
    const message_id = msg.message_id;
    const dateStr = (0, import_obsidian5.moment)(msg.date * 1e3).format("YYYYMMDD");
    const extension = getExt2(file.file_path || "");
    return `${dateStr}-${message_id}.${extension}`;
  }
  async insertMessageToVault(content, options) {
    const release2 = await this.mutex.acquire();
    try {
      const savedPath = (options == null ? void 0 : options.msg) ? await getSavePath(this.vault, this.settings, options.msg) : await getSavePath(this.vault, this.settings);
      if (this.settings.reverse_order) {
        await insertMessageAtTop(this.vault, content, savedPath);
      } else {
        await insertMessage(this.vault, content, savedPath);
      }
    } catch (error) {
      console.error(`Error inserting message to vault: ${error}`);
      throw error;
    } finally {
      release2();
    }
  }
};

// src/settings.ts
var import_obsidian6 = require("obsidian");
var Mustache2 = __toESM(require_mustache());
var TGInboxSettingTab = class extends import_obsidian6.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    const botSettingsTitle = containerEl.createDiv({
      cls: "bot-settings-title"
    });
    new import_obsidian6.Setting(botSettingsTitle).setName("Bot").setHeading();
    this.statusEl = botSettingsTitle.createDiv({
      cls: "tg-inbox-status"
    });
    this.updateStatus();
    this.updateId = window.setInterval(async () => {
      await this.updateStatus();
    }, 5e3);
    new import_obsidian6.Setting(containerEl).setName("Bot token").setDesc("Get your bot token from @BotFather").addText(
      (text) => text.setPlaceholder("Enter your bot token").setValue(this.plugin.settings.token).onChange(async (value) => {
        this.plugin.settings.token = value;
        await this.plugin.saveSettings();
      })
    ).addButton((button) => {
      button.setButtonText("Restart").onClick(async () => {
        this.plugin.launchBot();
        this.statusEl.setText("Restarting...");
      });
    });
    new import_obsidian6.Setting(containerEl).setName("Allowed users").setDesc(
      "List of usernames or IDs of users whose messages will be received. Separate multiple entries with commas."
    ).addText(
      (text) => text.setPlaceholder("Enter Telegram usernames or id").setValue(this.plugin.settings.allow_users.join(",")).onChange(async (value) => {
        this.plugin.settings.allow_users = value.split(",");
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian6.Setting(containerEl).setName("Message formatting").setHeading();
    new import_obsidian6.Setting(containerEl).setName("Download media").setDesc("Toggle to download media files along with messages.").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.download_media).onChange(async (value) => {
        this.plugin.settings.download_media = value;
        await this.plugin.saveSettings();
        this.display();
      })
    );
    if (this.plugin.settings.download_media) {
      new import_obsidian6.Setting(containerEl).setName("Download directory").setDesc("Specify the directory for downloading media files").addText(
        (text) => text.setPlaceholder("Enter download directory").setValue(this.plugin.settings.download_dir).onChange(async (value) => {
          this.plugin.settings.download_dir = value;
          await this.plugin.saveSettings();
        })
      );
    }
    const message_template_desc = document.createDocumentFragment();
    message_template_desc.append("Customize the message template. ");
    const message_template_wiki = document.createElement("a");
    message_template_wiki.href = "https://github.com/icealtria/obsidian-telegram-inbox/wiki/Message-template";
    message_template_wiki.text = "Learn more";
    message_template_desc.append(message_template_wiki);
    new import_obsidian6.Setting(containerEl).setName("Message template").setDesc(message_template_desc).addTextArea(
      (textArea) => {
        textArea.inputEl.rows = 3;
        textArea.setValue(this.plugin.settings.message_template).onChange(async (value) => {
          this.plugin.settings.message_template = value;
          await this.plugin.saveSettings();
        });
      }
    ).addButton((button) => {
      button.setButtonText("Validate").onClick(
        () => {
          try {
            Mustache2.parse(this.plugin.settings.message_template);
            templateValidStatus.setText("\u2705 Template format is correct. This is to ensure that the program does not crash, doesn't mean the fields are correct.");
          } catch (err) {
            console.error("Error parsing message template:", err);
            templateValidStatus.setText(`\u274C Error parsing template: ${err.message}`);
          }
        }
      );
    });
    const templateValidStatus = containerEl.createDiv();
    new import_obsidian6.Setting(containerEl).setName("Advanced").setHeading();
    new import_obsidian6.Setting(containerEl).setName("Reverse order").setDesc("Reverse the order of messages. This is useful if you want to see the latest messages first.").addToggle((toggle) => {
      toggle.setValue(this.plugin.settings.reverse_order).onChange(async (value) => {
        this.plugin.settings.reverse_order = value;
        await this.plugin.saveSettings();
      });
    });
    new import_obsidian6.Setting(containerEl).setName("Disable automatically receiving on Startup").setDesc("If it is disabled, you will need to manually run a command to start bot or get updates.").addToggle((toggle) => {
      toggle.setValue(this.plugin.settings.disable_auto_reception).onChange(async (value) => {
        this.plugin.settings.disable_auto_reception = value;
        await this.plugin.saveSettings();
      });
    });
    new import_obsidian6.Setting(containerEl).setName("Markdown escaper").setDesc("Use Markdown escaper for text. For example: '[link](https://example.com)' will display as '[link](https://example.com)' instead of a link.").addToggle((toggle) => {
      toggle.setValue(this.plugin.settings.markdown_escaper).onChange(async (value) => {
        this.plugin.settings.markdown_escaper = value;
        await this.plugin.saveSettings();
      });
    });
    new import_obsidian6.Setting(containerEl).setName("Save to custom path").setDesc("Toggle to save messages to a custom path.").addToggle((toggle) => {
      toggle.setValue(this.plugin.settings.is_custom_file).onChange(async (value) => {
        this.plugin.settings.is_custom_file = value;
        await this.plugin.saveSettings();
        this.display();
      });
    });
    const custom_path_desc = document.createDocumentFragment();
    custom_path_desc.append("Specify the path for saving messages. ");
    const custom_path_wiki = document.createElement("a");
    custom_path_wiki.href = "https://github.com/icealtria/obsidian-telegram-inbox/wiki/Custom-path";
    custom_path_wiki.text = "Learn more";
    custom_path_desc.append(custom_path_wiki);
    if (this.plugin.settings.is_custom_file) {
      new import_obsidian6.Setting(containerEl).setName("Custom path").setDesc(custom_path_desc).addText((text) => {
        text.setPlaceholder("Default: Telegram-Inbox.md").setValue(this.plugin.settings.custom_file_path).onChange((value) => {
          this.plugin.settings.custom_file_path = value;
          this.plugin.saveSettings();
        });
      });
    }
  }
  hide() {
    window.clearInterval(this.updateId);
  }
  async updateStatus() {
    try {
      const me = await this.plugin.getBotInfo();
      if (me) {
        this.statusEl.setText(`\u2705 Bot connected as @${me.username}`);
      } else {
        this.statusEl.setText("\u274C Bot not connected");
      }
    } catch (e) {
      this.statusEl.setText("\u274C Bot not connected");
    }
  }
};

// src/main.ts
var DEFAULT_SETTINGS = {
  token: "",
  marker: "#inbox",
  allow_users: [],
  download_dir: "/assets",
  download_media: false,
  markdown_escaper: false,
  message_template: "{{{text}}}",
  is_custom_file: false,
  custom_file_path: "Telegram-Inbox.md",
  disable_auto_reception: false,
  reverse_order: false
};
var TGInbox = class extends import_obsidian7.Plugin {
  async onload() {
    this.addSettingTab(new TGInboxSettingTab(this.app, this));
    this.addCommands();
    await this.loadSettings();
    if (this.settings.disable_auto_reception) {
      this.addRibbonIcon("send", "Telegram Inbox: Get Updates", () => {
        var _a;
        (_a = this.bot) == null ? void 0 : _a.getUpdates();
      });
    }
    this.launchBot();
  }
  addCommands() {
    this.addCommand({
      id: "tg-inbox-getupdates",
      name: "Get Updates",
      callback: () => {
        var _a;
        return (_a = this.bot) == null ? void 0 : _a.getUpdates();
      }
    });
    this.addCommand({
      id: "tg-inbox-start",
      name: "Start Telegram Bot",
      callback: () => this.startBot()
    });
    this.addCommand({
      id: "tg-inbox-stop",
      name: "Stop Telegram Bot",
      callback: () => this.stopBot()
    });
  }
  async getBotInfo() {
    if (this.bot) {
      return this.bot.bot.api.getMe();
    }
    return null;
  }
  async onunload() {
    this.stopBot();
    console.log("telegram inbox unloaded");
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
  async launchBot() {
    try {
      if (!this.settings.token) {
        new import_obsidian7.Notice("Telegram bot token not set");
        return;
      }
      await this.stopBot();
      this.bot = new TelegramBot(this.app.vault, this.settings);
      if (!this.settings.disable_auto_reception) {
        this.startBot();
      }
    } catch (error) {
      console.error("Error launching bot:", error);
      new import_obsidian7.Notice("Error launching bot");
      this.bot = null;
    }
  }
  async startBot() {
    new import_obsidian7.Notice("Telegram bot starting");
    if (this.bot) {
      this.bot.start();
    }
  }
  async stopBot() {
    try {
      if (this.bot) {
        await this.bot.bot.stop();
        console.log("bot stopped");
        new import_obsidian7.Notice("Telegram bot stopped");
      }
    } catch (error) {
      console.error("Error stopping bot:", error);
    }
  }
};
/*! Bundled license information:

mustache/mustache.js:
  (*!
   * mustache.js - Logic-less {{mustache}} templates with JavaScript
   * http://github.com/janl/mustache.js
   *)
*/
